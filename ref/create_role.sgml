<!--
doc/src/sgml/ref/create_role.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEROLE">
 <indexterm zone="sql-createrole">
  <primary>CREATE ROLE</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE ROLE</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE ROLE</refname>
  <refpurpose>새 데이터베이스 롤 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE ROLE <replaceable class="PARAMETER">이름</replaceable> [ [ WITH ] <replaceable class="PARAMETER">옵션</replaceable> [ ... ] ]

<phrase><replaceable class="PARAMETER">옵션</replaceable> 자리에는:</phrase>

      SUPERUSER | NOSUPERUSER
    | CREATEDB | NOCREATEDB
    | CREATEROLE | NOCREATEROLE
    | INHERIT | NOINHERIT
    | LOGIN | NOLOGIN
    | REPLICATION | NOREPLICATION
    | BYPASSRLS | NOBYPASSRLS
    | CONNECTION LIMIT <replaceable class="PARAMETER">접속제한</replaceable>
    | [ ENCRYPTED ] PASSWORD '<replaceable class="PARAMETER">비밀번호</replaceable>'
    | VALID UNTIL '<replaceable class="PARAMETER">타임스탬프</replaceable>'
    | IN ROLE <replaceable class="PARAMETER">롤이름</replaceable> [, ...]
    | IN GROUP <replaceable class="PARAMETER">롤이름</replaceable> [, ...]
    | ROLE <replaceable class="PARAMETER">롤이름</replaceable> [, ...]
    | ADMIN <replaceable class="PARAMETER">롤이름</replaceable> [, ...]
    | USER <replaceable class="PARAMETER">롤이름</replaceable> [, ...]
    | SYSID <replaceable class="PARAMETER">uid</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>설명</title>

  <para>
   <command>CREATE ROLE</command> 명령은
   <productname>PostgreSQL</productname> 데이터베이스 클러스터에
   새 롤을 추가한다.  하나의 롤은
   데이터베이스 개체들을 소유할 수 있고, 
   데이터베이스 권한을 가질 수 있다.
   롤은 그 사용 용도에 따라, <quote>사용자</>도 되고, 
   <quote>그룹</>도 되고, 둘 다도 될 수 있다.
   롤 관리는 <xref linkend="user-manag">에서,
   롤 인증은 <xref linkend="client-authentication">에서 자세히
   다룬다.
   이 명령을 실행하려면, 사용자가 <literal>CREATEROLE</> 권한이 있거나
   슈퍼유저여야 한다.
  </para>

  <para>
   롤은 데이터베이스 클러스터 전역 개체다.
   그래서, 그 클러스터 내 모든 데이터베이스에서 사용할 수 있다.
  </para>

  <para>
   롤을 <quote>역할</>로 옮길까 고민하다가 외래어 차용으로 결정했다. - 옮긴이
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

    <variablelist>
     <varlistentry>
      <term><replaceable class="parameter">이름</replaceable></term>
      <listitem>
       <para>
        새로 만들 롤 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SUPERUSER</literal></term>
      <term><literal>NOSUPERUSER</literal></term>
      <listitem>
       <para>
        These clauses determine whether the new role is a <quote>superuser</>,
        who can override all access restrictions within the database.
        Superuser status is dangerous and should be used only when really
        needed.  You must yourself be a superuser to create a new superuser.
        If not specified,
        <literal>NOSUPERUSER</literal> is the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEDB</></term>
      <term><literal>NOCREATEDB</></term>
      <listitem>
       <para>
        These clauses define a role's ability to create databases.  If
        <literal>CREATEDB</literal> is specified, the role being
        defined will be allowed to create new databases. Specifying
        <literal>NOCREATEDB</literal> will deny a role the ability to
        create databases. If not specified,
        <literal>NOCREATEDB</literal> is the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CREATEROLE</literal></term>
      <term><literal>NOCREATEROLE</literal></term>
      <listitem>
       <para>
        These clauses determine whether a role will be permitted to
        create new roles (that is, execute <command>CREATE ROLE</command>).
        A role with <literal>CREATEROLE</literal> privilege can also alter
        and drop other roles.
        If not specified,
        <literal>NOCREATEROLE</literal> is the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>INHERIT</literal></term>
      <term><literal>NOINHERIT</literal></term>
      <listitem>
       <para>
        These clauses determine whether a role <quote>inherits</> the
        privileges of roles it is a member of.
        A role with the <literal>INHERIT</literal> attribute can automatically
        use whatever database privileges have been granted to all roles
        it is directly or indirectly a member of.
        Without <literal>INHERIT</literal>, membership in another role
        only grants the ability to <command>SET ROLE</> to that other role;
        the privileges of the other role are only available after having
        done so.
        If not specified,
        <literal>INHERIT</literal> is the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>LOGIN</literal></term>
      <term><literal>NOLOGIN</literal></term>
      <listitem>
       <para>
        These clauses determine whether a role is allowed to log in;
        that is, whether the role can be given as the initial session
        authorization name during client connection.  A role having
        the <literal>LOGIN</literal> attribute can be thought of as a user.
        Roles without this attribute are useful for managing database
        privileges, but are not users in the usual sense of the word.
        If not specified,
        <literal>NOLOGIN</literal> is the default, except when
        <command>CREATE ROLE</> is invoked through its alternative spelling
        <xref linkend="sql-createuser">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>REPLICATION</literal></term>
      <term><literal>NOREPLICATION</literal></term>
      <listitem>
       <para>
        These clauses determine whether a role is a replication role.  A role
        must have this attribute (or be a superuser) in order to be able to
        connect to the server in replication mode (physical or logical
        replication) and in order to be able to create or drop replication
        slots.
        A role having the <literal>REPLICATION</> attribute is a very
        highly privileged role, and should only be used on roles actually
        used for replication. If not specified,
        <literal>NOREPLICATION</literal> is the default.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>BYPASSRLS</literal></term>
      <term><literal>NOBYPASSRLS</literal></term>
      <listitem>
       <para>
        These clauses determine whether a role bypasses every row-level
        security (RLS) policy.  <literal>NOBYPASSRLS</literal> is the default.
        Note that pg_dump will set <literal>row_security</literal> to
        <literal>OFF</literal> by default, to ensure all contents of a table are
        dumped out.  If the user running pg_dump does not have appropriate
        permissions, an error will be returned.  The superuser and owner of the
        table being dumped always bypass RLS.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONNECTION LIMIT</literal> <replaceable class="parameter">connlimit</replaceable></term>
      <listitem>
       <para>
        If role can log in, this specifies how many concurrent connections
        the role can make.  -1 (the default) means no limit. Note that only
        normal connections are counted towards this limit. Neither prepared
        transactions nor background worker connections are counted towards
        this limit.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term>[ <literal>ENCRYPTED</> ] <literal>PASSWORD</> <replaceable class="parameter">password</replaceable></term>
      <listitem>
       <para>
        Sets the role's password.  (A password is only of use for
        roles having the <literal>LOGIN</literal> attribute, but you
        can nonetheless define one for roles without it.)  If you do
        not plan to use password authentication you can omit this
        option.  If no password is specified, the password will be set
        to null and password authentication will always fail for that
        user.  A null password can optionally be written explicitly as
        <literal>PASSWORD NULL</literal>.
       </para>
       <note>
         <para>
           Specifying an empty string will also set the password to null,
           but that was not the case before <productname>PostgreSQL</>
           version 10. In earlier versions, an empty string could be used,
           or not, depending on the authentication method and the exact
           version, and libpq would refuse to use it in any case.
           To avoid the ambiguity, specifying an empty string should be
           avoided.
         </para>
       </note>
       <para>
        The password is always stored encrypted in the system catalogs. The
        <literal>ENCRYPTED</> keyword has no effect, but is accepted for
        backwards compatibility. The method of encryption is determined
        by the configuration parameter <xref linkend="guc-password-encryption">.
        If the presented password string is already in MD5-encrypted or
        SCRAM-encrypted format, then it is stored as-is regardless of
        <varname>password_encryption</> (since the system cannot decrypt
        the specified encrypted password string, to encrypt it in a
        different format).  This allows reloading of encrypted passwords
        during dump/restore.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>VALID UNTIL</literal> '<replaceable class="parameter">timestamp</replaceable>'</term>
      <listitem>
       <para>
        The <literal>VALID UNTIL</literal> clause sets a date and
        time after which the role's password is no longer valid.  If
        this clause is omitted the password will be valid for all time.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IN ROLE</> <replaceable class="parameter">role_name</replaceable></term>
      <listitem>
       <para>
        The <literal>IN ROLE</literal> clause lists one or more existing
        roles to which the new role will be immediately added as a new
        member.  (Note that there is no option to add the new role as an
        administrator; use a separate <command>GRANT</> command to do that.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IN GROUP</> <replaceable class="parameter">role_name</replaceable></term>
      <listitem>
       <para><literal>IN GROUP</literal> is an obsolete spelling of
        <literal>IN ROLE</>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ROLE</> <replaceable class="parameter">role_name</replaceable></term>
      <listitem>
       <para>
        The <literal>ROLE</literal> clause lists one or more existing
        roles which are automatically added as members of the new role.
        (This in effect makes the new role a <quote>group</>.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ADMIN</> <replaceable class="parameter">role_name</replaceable></term>
      <listitem>
       <para>
        The <literal>ADMIN</literal> clause is like <literal>ROLE</literal>,
        but the named roles are added to the new role <literal>WITH ADMIN
        OPTION</>, giving them the right to grant membership in this role
        to others.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>USER</> <replaceable class="parameter">role_name</replaceable></term>
      <listitem>
       <para>
        The <literal>USER</literal> clause is an obsolete spelling of
        the <literal>ROLE</> clause.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>SYSID</> <replaceable class="parameter">uid</replaceable></term>
      <listitem>
       <para>
        <literal>SYSID</literal> 옵션은 무시된다. 하위 버전 호환성 때문에 있는 
        옵션이다.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
 </refsect1>

 <refsect1>
  <title>참고</title>

  <para>
   Use <xref linkend="SQL-ALTERROLE"> to
   change the attributes of a role, and <xref linkend="SQL-DROPROLE">
   to remove a role.  All the attributes
   specified by <command>CREATE ROLE</> can be modified by later
   <command>ALTER ROLE</> commands.
  </para>

  <para>
   The preferred way to add and remove members of roles that are being
   used as groups is to use
   <xref linkend="SQL-GRANT"> and
   <xref linkend="SQL-REVOKE">.
  </para>

  <para>
   The <literal>VALID UNTIL</> clause defines an expiration time for a
   password only, not for the role <foreignphrase>per se</>.  In
   particular, the expiration time is not enforced when logging in using
   a non-password-based authentication method.
  </para>

  <para>
   The <literal>INHERIT</> attribute governs inheritance of grantable
   privileges (that is, access privileges for database objects and role
   memberships).  It does not apply to the special role attributes set by
   <command>CREATE ROLE</> and <command>ALTER ROLE</>.  For example, being
   a member of a role with <literal>CREATEDB</> privilege does not immediately
   grant the ability to create databases, even if <literal>INHERIT</> is set;
   it would be necessary to become that role via
   <xref linkend="SQL-SET-ROLE"> before
   creating a database.
  </para>

  <para>
   The <literal>INHERIT</> attribute is the default for reasons of backwards
   compatibility: in prior releases of <productname>PostgreSQL</productname>,
   users always had access to all privileges of groups they were members of.
   However, <literal>NOINHERIT</> provides a closer match to the semantics
   specified in the SQL standard.
  </para>

  <para>
   Be careful with the <literal>CREATEROLE</> privilege. There is no concept of
   inheritance for the privileges of a <literal>CREATEROLE</>-role. That
   means that even if a role does not have a certain privilege but is allowed
   to create other roles, it can easily create another role with different
   privileges than its own (except for creating roles with superuser
   privileges). For example, if the role <quote>user</> has the
   <literal>CREATEROLE</> privilege but not the <literal>CREATEDB</> privilege,
   nonetheless it can create a new role with the <literal>CREATEDB</>
   privilege. Therefore, regard roles that have the <literal>CREATEROLE</>
   privilege as almost-superuser-roles.
  </para>

  <para>
   <productname>PostgreSQL</productname> includes a program <xref
   linkend="APP-CREATEUSER"> that has
   the same functionality as <command>CREATE ROLE</command> (in fact,
   it calls this command) but can be run from the command shell.
  </para>

  <para>
   The <literal>CONNECTION LIMIT</> option is only enforced approximately;
   if two new sessions start at about the same time when just one
   connection <quote>slot</> remains for the role, it is possible that
   both will fail.  Also, the limit is never enforced for superusers.
  </para>

  <para>
   Caution must be exercised when specifying an unencrypted password
   with this command.  The password will be transmitted to the server
   in cleartext, and it might also be logged in the client's command
   history or the server log.  The command <xref
   linkend="APP-CREATEUSER">, however, transmits
   the password encrypted.  Also, <xref linkend="app-psql">
   contains a command
   <command>\password</command> that can be used to safely change the
   password later.
  </para>
 </refsect1>

 <refsect1>
  <title>예제</title>

  <para>
   비밀번호 없는 로그인 가능한 롤:
<programlisting>
CREATE ROLE jonathan LOGIN;
</programlisting>
  </para>

  <para>
   비밀번호 있는 로그인 가능한 롤:
<programlisting>
CREATE USER davide WITH PASSWORD 'jw8s0F4';
</programlisting>
   (<command>CREATE USER</> 명령은 <command>CREATE ROLE</> 명령에
   자동으로 <literal>LOGIN</> 옵션을 사용하는 것과 같다.)
  </para>

  <para>
   비밀번호가 2005-01-01 00:00:00 까지만 유효한 로그인 가능한 롤:

<programlisting>
CREATE ROLE miriam WITH LOGIN PASSWORD 'jw8s0F4' VALID UNTIL '2005-01-01';
</programlisting>
  </para>

  <para>
   데이터베이스 만들기 권한과 롤 관리 권한이 있는 롤:
<programlisting>
CREATE ROLE admin WITH CREATEDB CREATEROLE;
</programlisting></para>
 </refsect1>

 <refsect1>
  <title>호환성</title>

  <para>
   <command>CREATE ROLE</command> 구문은 표준 SQL 구문이다.
   하지만 표준 구문에서는 다음 구문만 정의한다.
<synopsis>
CREATE ROLE <replaceable class="PARAMETER">이름</> [ WITH ADMIN <replaceable class="PARAMETER">롤이름</> ]
</synopsis>
   다중 초기 관리자와 여러 옵션들은 <productname>PostgreSQL</productname>
   확장 기능이다.
  </para>

  <para>
   SQL 표준에서는 사용자와 롤 개념을 다르게 정의하고 있으며,
   사용자를 정의하는 모든 명령은 각 데이터베이스에서 
   알아서 구현하도록 맡기고 있다.  
   <productname>PostgreSQL</productname>에서는 
   사용자와 롤을 같은 개체로 통합했다.  그래서, 
   롤 속성으로 표준보다 다양한 선택 옵션들이 있다.
  </para>

  <para>
   SQL 표준에서는, <literal>NOINHERIT</> 속성이면 사용자,
   <literal>INHERIT</> 속성이면 롤로 정의하고 있다.
  </para>
 </refsect1>

 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-set-role"></member>
   <member><xref linkend="sql-alterrole"></member>
   <member><xref linkend="sql-droprole"></member>
   <member><xref linkend="sql-grant"></member>
   <member><xref linkend="sql-revoke"></member>
   <member><xref linkend="app-createuser"></member>
  </simplelist>
 </refsect1>
</refentry>
