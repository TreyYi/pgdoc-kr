<!-- doc/src/sgml/ref/create_cast.sgml -->

<refentry id="SQL-CREATECAST">
 <indexterm zone="sql-createcast">
  <primary>CREATE CAST</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE CAST</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE CAST</refname>
  <refpurpose>새 형변환자 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE CAST (<replaceable>기존자료형</replaceable> AS <replaceable>대상자료형</replaceable>)
    WITH FUNCTION <replaceable>함수이름</replaceable> [ (<replaceable>인자자료형</replaceable> [, ...]) ]
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>기존자료형</replaceable> AS <replaceable>대상자료형</replaceable>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>기존자료형</replaceable> AS <replaceable>대상자료형</replaceable>)
    WITH INOUT
    [ AS ASSIGNMENT | AS IMPLICIT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createcast-description">
  <title>설명</title>

  <para>
   <command>CREATE CAST</command> 명령은 새 형변환자를 정의한다.  형변환자란
   두 종류의 자료형을 어떻게 서로 바꿀 것인지를 지정하는 것이다.
   예를 들어,
<programlisting>
SELECT CAST(42 AS float8);
</programlisting>
   구문은 42 라는 상수를 <type>float8</type> 자료형으로 바꾼다.
   이 때, 해당 형변환용으로 지정한 <literal>float8(int4)</>
   함수가 사용된다.  (이런 형변환 작업에서 사용할 적당한
   형변환자가 없다면 오류로 처리한다.)
  </para>

  <para>
   두 자료형은 서로(쌍방 또는 일방) <firstterm>내부 임의 변환</firstterm>
   <firstterm>binary coercible</firstterm> 될 수 있다. 
   이것은 형 변환이 일어날 때, 어떠한 함수도 사용하지 않고, 
   <quote>그냥</quote> 바꾸는 것을 말한다.
   두 자료형이 내부적으로는 같은 자료형으로 처리하는 경우가 그렇다.
   예를 들어, <type>text</type> 형과 <type>varchar</type> 형이 대표적인
   내부 임의 변환을 하는 경우다.
   내부 임의 변환이 쌍방이 아닌 경우도 있다.  예를 들어,
   <type>xml</type> 형을 <type>text</type> 형으로 바꿀 때는 
   내부 임의 변환이 가능하지만, 그 반대인 경우는 
   xml 문법에 맞는지 유효성 검사를 하는 함수가 필요하기 때문이다.
   (쌍방 내부 임의 변환인 경우를 특히 이진 호환
   binary compatible 이라고 하기도 한다.)
  </para>

  <para>
   <literal>WITH INOUT</literal> 구문을 이용해서
   <firstterm>입출력 형변환자</> <firstterm>I/O conversion cast</>
   를 만들 수도 있다.
   입출력 형변화자는 기존 자료형의 출력 함수를 호출하고,
   대상 자료형의 입력 함수에 결과 문자열을 지정해서 처리한다.
   일반적으로 많은 경우에, 이런 처리 방식은 
   형 변환 작업용 분리된 형 변환 함수를 각각 만드는 일을 줄인다.
   입출력 형변화자는 일반 함수 기반 형변환자와 하는 일은 동일하다.
   구현 방법이 다를 뿐이다.
  </para>

  <para>
   사용자가 만드는 형 변환자는 기본적으로 명시적으로 지정해서
   사용한다.  명시적 사용법은 <literal>CAST(<replaceable>x</> AS
   <replaceable>자료형</>)</literal> 구문이나
   <replaceable>x</><literal>::</><replaceable>자료형</>
   구문을 사용한다.
  </para>

  <para>
   <literal>AS ASSIGNMENT</> 옵션을 사용하면, 
   대상 자료형 칼럼에 값을 대입하는 경우에는 
   묵시적으로 형변환이 일어난다.  예를 들어
   <literal>foo.f1</literal> 칼럼의 자료형이
   <type>text</type>형인 경우:
<programlisting>
INSERT INTO foo (f1) VALUES (42);
</programlisting>
   명령을 실행하면, <type>integer</type> 자료형을
   <type>text</type> 자료형으로 바꾸는 형 변환자가 있는데, 
   이 변환자에 <literal>AS ASSIGNMENT</> 옵션 추가 되어 있다면,
   그 형 변환자를 특별히 지정하지 않아도 묵시적으로 사용한다.
   (이런 형 변환자를 <firstterm>대입 형변환자</firstterm>
   <firstterm>assignment cast</firstterm> 라고 한다.)
  </para>

  <para>
   <literal>AS IMPLICIT</> 옵션을 사용하면, 
   어떤 상황에서 그냥 묵시적으로 형 변환을 한다.
   (이런 형 변환자를 
   <firstterm>묵시적 형변환자</firstterm> 
   <firstterm>implicit cast</firstterm> 라고 한다.)
   다음 예제를 보자:
<programlisting>
SELECT 2 + 4.0;
</programlisting>
   구문분석기는 두 상수를 각각 <type>integer</>형과 <type>numeric</>형으로 
   간주할 것이다.  이 때 <type>integer</>
   <literal>+</> <type>numeric</> 용 연산자는 없고, 
   <type>numeric</> <literal>+</> <type>numeric</> 용 연산자만 있는데,
   이 쿼리는 정상 실행 된다.
   <type>integer</> 형이 <type>numeric</> 형으로 바꾸는 <literal>AS IMPLICIT</>
   옵션이 지정된 묵시적 형변환자가 사용되었기 때문이다. &mdash;
   내부적으로 보면, 결국 구문분석기는 다음과 같이 쿼리를 재작성한다:
<programlisting>
SELECT CAST ( 2 AS numeric ) + 4.0;
</programlisting>
  </para>

  <para>
   시스템 카탈로그에서는 <type>numeric</> 형에서 
   <type>integer</> 형으로 바꾸는 형 변환자도 제공한다.
   이런 형변환자에 <literal>AS IMPLICIT</> 옵션이 있다면 &mdash; 
   실재로는 없다 &mdash; 구문분석기는
   그냥 <type>integer</> <literal>+</> <type>integer</> 연산을
   해 버릴 것이다.  그럼 앞에서 이야기한 <type>integer</>형에서
   <type>numeric</>형으로 바꾸는 형 변환자와 충돌이 생긴다.
   이렇게 되면 구문분석기는 자신이 어느 것을 선택하지 않고, 
   그냥 오류로 처리한다.  사용자가 결정하라고.
   이런 불편함을 해결하기 위한 어느 한 쪽이 묵시적 형변환을 
   사용한다면, 그 반대 쪽에 대해서는 같은 묵시적 형변환으로 
   지정하는 것에 대해서 꼼꼼히 확인해 봐야 한다.
  </para>

  <para>
   It is wise to be conservative about marking casts as implicit.  An
   overabundance of implicit casting paths can cause
   <productname>PostgreSQL</productname> to choose surprising
   interpretations of commands, or to be unable to resolve commands at
   all because there are multiple possible interpretations.  A good
   rule of thumb is to make a cast implicitly invokable only for
   information-preserving transformations between types in the same
   general type category.  For example, the cast from <type>int2</type> to
   <type>int4</type> can reasonably be implicit, but the cast from
   <type>float8</type> to <type>int4</type> should probably be
   assignment-only.  Cross-type-category casts, such as <type>text</>
   to <type>int4</>, are best made explicit-only.
  </para>

  <note>
   <para>
    Sometimes it is necessary for usability or standards-compliance reasons
    to provide multiple implicit casts among a set of types, resulting in
    ambiguity that cannot be avoided as above.  The parser has a fallback
    heuristic based on <firstterm>type categories</> and <firstterm>preferred
    types</> that can help to provide desired behavior in such cases.  See
    <xref linkend="sql-createtype"> for
    more information.
   </para>
  </note>

  <para>
   To be able to create a cast, you must own the source or the target data type
   and have <literal>USAGE</literal> privilege on the other type.  To create a
   binary-coercible cast, you must be superuser.  (This restriction is made
   because an erroneous binary-coercible cast conversion can easily crash the
   server.)
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

   <variablelist>
    <varlistentry>
     <term><replaceable>기존자료형</replaceable></term>

     <listitem>
      <para>
       해당 형변환자용 기존 자료형(입력 자료형) 이름.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>대상자료형</replaceable></term>

     <listitem>
      <para>
       해당 형변환자용 대상 자료형(출력 자료형) 이름.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal><replaceable>함수이름</replaceable>[(<replaceable>인자자료형</replaceable> [, ...])]</literal></term>

     <listitem>
      <para>
       형변환 작업을 할 함수 이름.  이 함수 이름에 스키마 이름도 함께
       지정할 수 있다.  스키마 이름이 없으면, search_path 
       설정값으로 지정한 스키마 안에서 그 함수를 찾는다.
       해당 함수의 반환 자료형은 이 명령에서 지정하는 대상 자료형과 
       같아야 한다.  이 함수의 인자에 대해서는 아래에서 설명한다.
       인자 자료형을 지정하지 않는다면, 그 함수는 해당 스키마 내에서 
       하나만 있어야 한다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITHOUT FUNCTION</literal></term>

     <listitem>
      <para>
       형변환 작업용 함수가 필요 없는 경우임을 지정한다.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITH INOUT</literal></term>

     <listitem>
      <para>
       Indicates that the cast is an I/O conversion cast, performed by
       invoking the output function of the source data type, and passing the
       resulting string to the input function of the target data type.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS ASSIGNMENT</literal></term>

     <listitem>
      <para>
       Indicates that the cast can be invoked implicitly in assignment
       contexts.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS IMPLICIT</literal></term>

     <listitem>
      <para>
       모든 상황에서 이 형변환자가 자동 사용될 수 있도록 지정한다.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   Cast implementation functions can have one to three arguments.
   The first argument type must be identical to or binary-coercible from
   the cast's source type.  The second argument,
   if present, must be type <type>integer</>; it receives the type
   modifier associated with the destination type, or <literal>-1</>
   if there is none.  The third argument,
   if present, must be type <type>boolean</>; it receives <literal>true</>
   if the cast is an explicit cast, <literal>false</> otherwise.
   (Bizarrely, the SQL standard demands different behaviors for explicit and
   implicit casts in some cases.  This argument is supplied for functions
   that must implement such casts.  It is not recommended that you design
   your own data types so that this matters.)
  </para>

  <para>
   The return type of a cast function must be identical to or
   binary-coercible to the cast's target type.
  </para>

  <para>
   Ordinarily a cast must have different source and target data types.
   However, it is allowed to declare a cast with identical source and
   target types if it has a cast implementation function with more than one
   argument.  This is used to represent type-specific length coercion
   functions in the system catalogs.  The named function is used to
   coerce a value of the type to the type modifier value given by its
   second argument.
  </para>

  <para>
   When a cast has different source and
   target types and a function that takes more than one argument, it
   supports converting from one type to another and applying a length
   coercion in a single step.  When no such entry is available, coercion
   to a type that uses a type modifier involves two cast steps, one to
   convert between data types and a second to apply the modifier.
  </para>

  <para>
   A cast to or from a domain type currently has no effect.  Casting
   to or from a domain uses the casts associated with its underlying type.
  </para>

 </refsect1>

 <refsect1 id="sql-createcast-notes">
  <title>참고</title>

  <para>
   사용자 정의 형변환자는 <xref linkend="sql-dropcast"> 명령으로 지운다.
  </para>

  <para>
   양방향 형변환을 원하면, 각각의 형변환자를 만들어야 함을 기억해야 한다.
  </para>

 <indexterm zone="sql-createcast">
  <primary>cast</primary>
  <secondary>I/O 변환</secondary>
 </indexterm>

  <para>
   It is normally not necessary to create casts between user-defined types
   and the standard string types (<type>text</>, <type>varchar</>, and
   <type>char(<replaceable>n</>)</type>, as well as user-defined types that
   are defined to be in the string category).  <productname>PostgreSQL</>
   provides automatic I/O conversion casts for that. The automatic casts to
   string types are treated as assignment casts, while the automatic casts
   from string types are
   explicit-only.  You can override this behavior by declaring your own
   cast to replace an automatic cast, but usually the only reason to
   do so is if you want the conversion to be more easily invokable than the
   standard assignment-only or explicit-only setting.  Another possible
   reason is that you want the conversion to behave differently from the
   type's I/O function; but that is sufficiently surprising that you
   should think twice about whether it's a good idea.  (A small number of
   the built-in types do indeed have different behaviors for conversions,
   mostly because of requirements of the SQL standard.)
  </para>

  <para>
   While not required, it is recommended that you continue to follow this old
   convention of naming cast implementation functions after the target data
   type.  Many users are used to being able to cast data types using a
   function-style notation, that is
   <replaceable>typename</>(<replaceable>x</>).  This notation is in fact
   nothing more nor less than a call of the cast implementation function; it
   is not specially treated as a cast.  If your conversion functions are not
   named to support this convention then you will have surprised users.
   Since <productname>PostgreSQL</> allows overloading of the same function
   name with different argument types, there is no difficulty in having
   multiple conversion functions from different types that all use the
   target type's name.
  </para>

  <note>
   <para>
    Actually the preceding paragraph is an oversimplification: there are
    two cases in which a function-call construct will be treated as a cast
    request without having matched it to an actual function.
    If a function call <replaceable>name</>(<replaceable>x</>) does not
    exactly match any existing function, but <replaceable>name</> is the name
    of a data type and <structname>pg_cast</> provides a binary-coercible cast
    to this type from the type of <replaceable>x</>, then the call will be
    construed as a binary-coercible cast.  This exception is made so that
    binary-coercible casts can be invoked using functional syntax, even
    though they lack any function.  Likewise, if there is no
    <structname>pg_cast</> entry but the cast would be to or from a string
    type, the call will be construed as an I/O conversion cast.  This
    exception allows I/O conversion casts to be invoked using functional
    syntax.
   </para>
  </note>

  <note>
   <para>
    There is also an exception to the exception: I/O conversion casts from
    composite types to string types cannot be invoked using functional
    syntax, but must be written in explicit cast syntax (either
    <literal>CAST</> or <literal>::</> notation).  This exception was added
    because after the introduction of automatically-provided I/O conversion
    casts, it was found too easy to accidentally invoke such a cast when
    a function or column reference was intended.
   </para>
  </note>
 </refsect1>


 <refsect1 id="sql-createcast-examples">
  <title>예제</title>

  <para>
   To create an assignment cast from type <type>bigint</type> to type
   <type>int4</type> using the function <literal>int4(bigint)</literal>:
<programlisting>
CREATE CAST (bigint AS int4) WITH FUNCTION int4(bigint) AS ASSIGNMENT;
</programlisting>
   (이 형변환자는 이미 시스템에서 제공하는 형변환자다.)
  </para>
 </refsect1>

 <refsect1 id="sql-createcast-compat">
  <title>호환성</title>

  <para>
   <command>CREATE CAST</command> 구문은 표준 <acronym>SQL</acronym>
   구문을 따른다.
   표준 SQL에는 함수를 사용하지 않는 경우와,
   함수 인자를 지정하는 구문은 허용하지 않는다. 또한
   <literal>AS IMPLICIT</> 옵션은 <productname>PostgreSQL</productname>
   확장 기능이다.
  </para>
 </refsect1>


 <refsect1 id="sql-createcast-seealso">
  <title>관련 항목</title>

  <para>
   <xref linkend="sql-createfunction">,
   <xref linkend="sql-createtype">,
   <xref linkend="sql-dropcast">
  </para>
 </refsect1>

</refentry>
