<!--
doc/src/sgml/ref/create_index.sgml
PostgreSQL documentation
-->

<refentry id="SQL-CREATEINDEX">
 <indexterm zone="sql-createindex">
  <primary>CREATE INDEX</primary>
 </indexterm>

 <refmeta>
  <refentrytitle>CREATE INDEX</refentrytitle>
  <manvolnum>7</manvolnum>
  <refmiscinfo>SQL - Language Statements</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE INDEX</refname>
  <refpurpose>새 인덱스 정의</refpurpose>
 </refnamediv>

 <refsynopsisdiv>
<synopsis>
CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <replaceable class="parameter">이름</replaceable> ] ON <replaceable class="parameter">테이블이름</replaceable> [ USING <replaceable class="parameter">색인방법</replaceable> ]
    ( { <replaceable class="parameter">칼럼이름</replaceable> | ( <replaceable class="parameter">표현식</replaceable> ) } [ COLLATE <replaceable class="parameter">문자정렬규칙</replaceable> ] [ <replaceable class="parameter">연산자클래스</replaceable> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <replaceable class="PARAMETER">저장_매개변수</replaceable> = <replaceable class="PARAMETER">값</replaceable> [, ... ] ) ]
    [ TABLESPACE <replaceable class="parameter">테이블스페이스이름</replaceable> ]
    [ WHERE <replaceable class="parameter">조건절</replaceable> ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>설명</title>

  <para>
   <command>CREATE INDEX</command> 명령은 
   해당 릴레이션 (테이블이나 구체화한 뷰)의 특정 칼럼을 기준으로
   인덱스를 만든다.  인덱스를 만드는 첫번째 목적은 데이터베이스 성능을
   높이는데 있다. (물론 잘못 사용하면 성능을 떨어뜨리기도 한다.)
  </para>

  <para>
   인덱스 키 필드는 칼럼 이름이나, 어떤 계산식을 사용한다.
   색인 방법이 다중 칼럼 인덱스를 지원하면, 다중 필드를 
   지정해서 인덱스를 만들 수 있다.
   (색인 방법: btree, hash ... 이런 인덱스 종류를 말한다 - 옮긴이)
  </para>

  <para>
   인덱스 필드로 사용할 수 있는 계산식은 그 계산 결과가 인덱스 
   자료로 사용되는 것이다. 그 계산 되는 자료는 테이블의 특정
   칼럼일 수도 있고, 여러 칼럼일 수도 있다.  이 기능은
   조회 쿼리에서 어떤 계산식에 의한 결과를 빠르게 찾는데 
   도움을 준다.  예를 들어, 대소문자를 구분하지 않고, 
   무조건 대문자로 어떤 자료를 찾으려고 할때, 
   인덱스 필드로 <literal>upper(col)</> 계산식을 사용해서 
   인덱스를 만들고, 조회 쿼리에서 <literal>WHERE upper(col) = 'JIM'</>
   구문을 사용하면, 그 인덱스를 사용할 수 있다.
  </para>

  <para>
   <productname>PostgreSQL</productname>에서 기본 제공하는 색인 방법은
   B-tree, hash, GiST, SP-GiST, GIN, BRIN 이다.
   또한 사용자가 직접 이 색인 방법을 만들어 사용할 수 있지만,
   상당히 복잡한 과정을 거친다.
  </para>

  <para>
    인덱스를 만드는 구문에서 <literal>WHERE</literal> 조건절을 
    사용해서 <firstterm>부분 인덱스</firstterm>를 만들 수도 있다.
    부분 인덱스란 테이블 전체 자료를 대상으로 하지 않고, 
    특정 부분 자료를 대상으로 인덱스를 만드는 것이다.
    예를 들어, 주문 테이블에서 청구 상태 기준으로 미청구 주문이
    적고, 청구 주문이 많은데, 업무에서는 이 미청구 주문을 대상으로 하는
    작업이 많은 경우, 인덱스를 미청구 주문을 대상으로만 만들어
    성능을 높일 수 있다. (인덱스 크기가 줄어들 것이며, 그 만큼 
    디스크 사용량이 줄기 때문이다 - 옮긴이)
    또 다른 사용법으로, <literal>UNIQUE</literal> 인덱스를 만들 수 없는
    자료인데, <literal>WHERE</literal> 조건절을 이용해서, 
    유일성을 보장하는 인덱스로 만들어 사용하는 것이다. 이 부분은
    <xref linkend="indexes-partial">에서 자세히 다룬다.
  </para>

  <para>
    단순 인덱스는 단일, 또는 지정한 칼럼들만 대상으로 하지만,
    <literal>WHERE</literal> 조건절을 하면 그 인덱스용 칼럼 뿐만 아니라,
    그 외 칼럼들에 대해서도 조건을 적용할 수 있어 꽤 유용하다. 
    현재, 이 <literal>WHERE</literal> 조건절에서는 서브쿼리와
    집계 작업용 계산식은 사용할 수 없다.
    이 제약은 인덱스 칼럼 대신 사용할 수 있는 계산식에서도 
    같다.
  </para>

  <para>
   인덱스를 만들 때 사용하는 함수나 연산자는 반드시 <quote>immutable</>
   속성이 있어야 하는 것이여야 한다.
   이 속성은 입력에 대한 출력값이 항상 같다는 것을 뜻한다(어떤
   테이블을 참조하거나, 현재 시간을 출력하는 작업은 이런 경우가 
   아니다).  이렇게 <quote>immutable</> 속성이 있어야
   인덱스 역할을 제대로 하기 때문이다.  사용자 정의 함수를 사용해서
   인덱스 필드로 사용하거나,  <literal>WHERE</literal> 조건절에서
   사용하려고 한다면, 반드시 이 점을 기억해야 한다.
  </para>
 </refsect1>

 <refsect1>
  <title>매개 변수</title>

    <variablelist>
     <varlistentry>
      <term><literal>UNIQUE</literal></term>
      <listitem>
       <para>
        유니크 인덱스를 만들 때 사용.
        해당 필드 값은 해당 테이블에 유일하게 있어야 함을 뜻한다.
        같은 자료를 입력 하거나, 이미 있는 값으로 바꾸려고 하면 오류로 처리한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CONCURRENTLY</literal></term>
      <listitem>
       <para>
        이 옵션을 사용하면, <productname>PostgreSQL</> 서버는
        해당 테이블의 insert, update, delete 작업을 허용하면서
        인덱스를 만든다.  일반적 인덱스 만들기는 해당 테이블을 읽기 전용으로
        잠근다.
        이 옵션을 사용할 때는 여러 제약 조건들이 있다.
        이 옵션을 사용하려면  <xref linkend="SQL-CREATEINDEX-CONCURRENTLY"
        endterm="SQL-CREATEINDEX-CONCURRENTLY-title"> 설명서를
        꼭 읽고 사용해야 한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>IF NOT EXISTS</literal></term>
      <listitem>
       <para>
        해당 이름과 같은 인덱스가 이미 있어도 오류로 처리하지 않고, 
        알림 메시지만 보여주고 마친다.  물론 같은 이름의 개체가
        정확히 같은 인덱스인지는 확인하지 않는다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">이름</replaceable></term>
      <listitem>
       <para>
        새로 만들 인덱스 이름.
        이 이름에는 스키마 이름을 지정하지 않는다.  인덱스의 소속 스키마는
        항상 그 테이블의 스키마와 같기 때문이다.
        이 이름을 생략하는 경우, <productname>PostgreSQL</>에서는
        해당 테이블과 해당 칼럼 이름의 조함으로 이 인덱스 이름을 
        자동으로 만들어 사용한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">테이블이름</replaceable></term>
      <listitem>
       <para>
        대상 테이블 이름. (스키마 이름 포함)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">색인방법</replaceable></term>
      <listitem>
       <para>
        해당 인덱스의 색인 방법을 지정한다. 사용할 수 있는 값:
        <literal>btree</literal>, <literal>hash</literal>,
        <literal>gist</literal>, <literal>spgist</>, <literal>gin</>, 
        <literal>brin</>.
        <literal>btree</literal>가 기본값이다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">칼럼이름</replaceable></term>
      <listitem>
       <para>
        해당 테이블의 칼럼 이름.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">표현식</replaceable></term>
      <listitem>
       <para>
        하나의 표현식은 해당 테이블의 하나 또는 그 이상의 칼럼을 
        기반으로 한다.  표현식은 일반적으로 괄호로 둘러싼다.
        한 함수만 호출하는 식이라면, 그럴 필요는 없다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">문자정렬규칙</replaceable></term>
      <listitem>
       <para>
        해당 인덱스가 문자열 자료를 대상으로 한다면, 
        그 자료의 정렬 규칙을 지정한다.  기본적으로
        그 해당 자료의 자료형 기본 문자 정렬 규칙을 사용한다.
        이 옵션을 사용해서 특정 정렬 규칙을 사용했다면,
        조회 쿼리에서도 이 정렬 규칙을 지정해야, 
        만든 인덱스를 사용해서 조회 작업을 진행한다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">연산자클래스</replaceable></term>
      <listitem>
       <para>
        연산자 클래스 이름. 아래에서 설명함.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ASC</></term>
      <listitem>
       <para>
        오름 차순 정렬 (기본값).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DESC</></term>
      <listitem>
       <para>
        내림 차순 정렬.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS FIRST</></term>
      <listitem>
       <para>
        null 값 먼저 정렬. <literal>DESC</> 인덱스인 경우는 기본값.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>NULLS LAST</></term>
      <listitem>
       <para>
        null 값 나중에 정렬. <literal>DESC</> 옵션을 지정하지 않은
        인덱스인 경우는 기본값.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">저장_매개변수</replaceable></term>
      <listitem>
       <para>
        색인 방법에서 사용하는 저장 매개 변수 이름.
        <xref linkend="sql-createindex-storage-parameters" endterm="sql-createindex-storage-parameters-title"> 참조.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">테이블스페이스이름</replaceable></term>
      <listitem>
       <para>
        이 인덱스가 저장될 테이블스페이스 이름.  지정하지 않으면,
        <xref linkend="guc-default-tablespace"> 설정값의 테이블스페이스가
        사용되며, 임시 테이블의 인덱스라면, 
        <xref linkend="guc-temp-tablespaces"> 설정값의 테이블스페이스가
        사용된다.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">조건절</replaceable></term>
      <listitem>
       <para>
        부분 인덱스를 만들 조건절 표현식.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  <refsect2 id="SQL-CREATEINDEX-storage-parameters">
   <title id="SQL-CREATEINDEX-storage-parameters-title">인덱스 저장 매개 변수</title>

   <para>
    The optional <literal>WITH</> clause specifies <firstterm>storage
    parameters</> for the index.  Each index method has its own set of allowed
    storage parameters.  The B-tree, hash, GiST and SP-GiST index methods all
    accept this parameter:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>fillfactor</></term>
    <listitem>
     <para>
      The fillfactor for an index is a percentage that determines how full
      the index method will try to pack index pages.  For B-trees, leaf pages
      are filled to this percentage during initial index build, and also
      when extending the index at the right (adding new largest key values).
      If pages
      subsequently become completely full, they will be split, leading to
      gradual degradation in the index's efficiency.  B-trees use a default
      fillfactor of 90, but any integer value from 10 to 100 can be selected.
      If the table is static then fillfactor 100 is best to minimize the
      index's physical size, but for heavily updated tables a smaller
      fillfactor is better to minimize the need for page splits.  The
      other index methods use fillfactor in different but roughly analogous
      ways; the default fillfactor varies between methods.
     </para>
    </listitem>
   </varlistentry>
   </variablelist>

   <para>
    GiST indexes additionally accept this parameter:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>buffering</></term>
    <listitem>
    <para>
     Determines whether the buffering build technique described in
     <xref linkend="gist-buffering-build"> is used to build the index. With
     <literal>OFF</> it is disabled, with <literal>ON</> it is enabled, and
     with <literal>AUTO</> it is initially disabled, but turned on
     on-the-fly once the index size reaches <xref linkend="guc-effective-cache-size">. The default is <literal>AUTO</>.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

   <para>
    GIN indexes accept different parameters:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>fastupdate</></term>
    <listitem>
    <para>
     This setting controls usage of the fast update technique described in
     <xref linkend="gin-fast-update">.  It is a Boolean parameter:
     <literal>ON</> enables fast update, <literal>OFF</> disables it.
     (Alternative spellings of <literal>ON</> and <literal>OFF</> are
     allowed as described in <xref linkend="config-setting">.)  The
     default is <literal>ON</>.
    </para>

    <note>
     <para>
      Turning <literal>fastupdate</> off via <command>ALTER INDEX</> prevents
      future insertions from going into the list of pending index entries,
      but does not in itself flush previous entries.  You might want to
      <command>VACUUM</> the table or call <function>gin_clean_pending_list</>
      function afterward to ensure the pending list is emptied.
     </para>
    </note>
    </listitem>
   </varlistentry>
   </variablelist>
   <variablelist>
   <varlistentry>
    <term><literal>gin_pending_list_limit</></term>
    <listitem>
    <para>
     Custom <xref linkend="guc-gin-pending-list-limit"> parameter.
     This value is specified in kilobytes.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>

   <para>
    <acronym>BRIN</> indexes accept different parameters:
   </para>

   <variablelist>
   <varlistentry>
    <term><literal>pages_per_range</></term>
    <listitem>
    <para>
     Defines the number of table blocks that make up one block range for
     each entry of a <acronym>BRIN</> index (see <xref linkend="brin-intro">
     for more details).  The default is <literal>128</>.
    </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>autosummarize</></term>
    <listitem>
    <para>
     Defines whether a summarization run is invoked for the previous page
     range whenever an insertion is detected on the next one.
    </para>
    </listitem>
   </varlistentry>
   </variablelist>
  </refsect2>

  <refsect2 id="SQL-CREATEINDEX-CONCURRENTLY">
   <title id="SQL-CREATEINDEX-CONCURRENTLY-title">Building Indexes Concurrently</title>

   <indexterm zone="SQL-CREATEINDEX-CONCURRENTLY">
   <primary>index</primary>
   <secondary>building concurrently</secondary>
   </indexterm>

   <para>
    Creating an index can interfere with regular operation of a database.
    Normally <productname>PostgreSQL</> locks the table to be indexed against
    writes and performs the entire index build with a single scan of the
    table. Other transactions can still read the table, but if they try to
    insert, update, or delete rows in the table they will block until the
    index build is finished. This could have a severe effect if the system is
    a live production database.  Very large tables can take many hours to be
    indexed, and even for smaller tables, an index build can lock out writers
    for periods that are unacceptably long for a production system.
   </para>

   <para>
    <productname>PostgreSQL</> supports building indexes without locking
    out writes.  This method is invoked by specifying the
    <literal>CONCURRENTLY</> option of <command>CREATE INDEX</>.
    When this option is used,
    <productname>PostgreSQL</> must perform two scans of the table, and in
    addition it must wait for all existing transactions that could potentially
    modify or use the index to terminate.  Thus
    this method requires more total work than a standard index build and takes
    significantly longer to complete.  However, since it allows normal
    operations to continue while the index is built, this method is useful for
    adding new indexes in a production environment.  Of course, the extra CPU
    and I/O load imposed by the index creation might slow other operations.
   </para>

   <para>
    In a concurrent index build, the index is actually entered into
    the system catalogs in one transaction, then two table scans occur in
    two more transactions.  Before each table scan, the index build must
    wait for existing transactions that have modified the table to terminate.
    After the second scan, the index build must wait for any transactions
    that have a snapshot (see <xref linkend="mvcc">) predating the second
    scan to terminate.  Then finally the index can be marked ready for use,
    and the <command>CREATE INDEX</> command terminates.
    Even then, however, the index may not be immediately usable for queries:
    in the worst case, it cannot be used as long as transactions exist that
    predate the start of the index build.
   </para>

   <para>
    If a problem arises while scanning the table, such as a deadlock or a
    uniqueness violation in a unique index, the <command>CREATE INDEX</>
    command will fail but leave behind an <quote>invalid</> index. This index
    will be ignored for querying purposes because it might be incomplete;
    however it will still consume update overhead. The <application>psql</>
    <command>\d</> command will report such an index as <literal>INVALID</>:

<programlisting>
postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 col    | integer |           |          | 
Indexes:
    "idx" btree (col) INVALID
</programlisting>

    The recommended recovery
    method in such cases is to drop the index and try again to perform
    <command>CREATE INDEX CONCURRENTLY</>.  (Another possibility is to rebuild
    the index with <command>REINDEX</>.  However, since <command>REINDEX</>
    does not support concurrent builds, this option is unlikely to seem
    attractive.)
   </para>

   <para>
    Another caveat when building a unique index concurrently is that the
    uniqueness constraint is already being enforced against other transactions
    when the second table scan begins.  This means that constraint violations
    could be reported in other queries prior to the index becoming available
    for use, or even in cases where the index build eventually fails.  Also,
    if a failure does occur in the second scan, the <quote>invalid</> index
    continues to enforce its uniqueness constraint afterwards.
   </para>

   <para>
    Concurrent builds of expression indexes and partial indexes are supported.
    Errors occurring in the evaluation of these expressions could cause
    behavior similar to that described above for unique constraint violations.
   </para>

   <para>
    Regular index builds permit other regular index builds on the
    same table to occur in parallel, but only one concurrent index build
    can occur on a table at a time.  In both cases, no other types of schema
    modification on the table are allowed meanwhile.  Another difference
    is that a regular <command>CREATE INDEX</> command can be performed within
    a transaction block, but <command>CREATE INDEX CONCURRENTLY</> cannot.
   </para>
  </refsect2>
 </refsect1>

 <refsect1>
  <title>참고</title>

  <para>
   See <xref linkend="indexes"> for information about when indexes can
   be used, when they are not used, and in which particular situations
   they can be useful.
  </para>

  <para>
   Currently, only the B-tree, GiST, GIN, and BRIN index methods support
   multicolumn indexes. Up to 32 fields can be specified by default.
   (This limit can be altered when building
   <productname>PostgreSQL</productname>.)  Only B-tree currently
   supports unique indexes.
  </para>

  <para>
   An <firstterm>operator class</firstterm> can be specified for each
   column of an index. The operator class identifies the operators to be
   used by the index for that column. For example, a B-tree index on
   four-byte integers would use the <literal>int4_ops</literal> class;
   this operator class includes comparison functions for four-byte
   integers. In practice the default operator class for the column's data
   type is usually sufficient. The main point of having operator classes
   is that for some data types, there could be more than one meaningful
   ordering. For example, we might want to sort a complex-number data
   type either by absolute value or by real part. We could do this by
   defining two operator classes for the data type and then selecting
   the proper class when making an index.  More information about
   operator classes is in <xref linkend="indexes-opclass"> and in <xref
   linkend="xindex">.
  </para>

  <para>
   For index methods that support ordered scans (currently, only B-tree),
   the optional clauses <literal>ASC</>, <literal>DESC</>, <literal>NULLS
   FIRST</>, and/or <literal>NULLS LAST</> can be specified to modify
   the sort ordering of the index.  Since an ordered index can be
   scanned either forward or backward, it is not normally useful to create a
   single-column <literal>DESC</> index &mdash; that sort ordering is already
   available with a regular index.  The value of these options is that
   multicolumn indexes can be created that match the sort ordering requested
   by a mixed-ordering query, such as <literal>SELECT ... ORDER BY x ASC, y
   DESC</>.  The <literal>NULLS</> options are useful if you need to support
   <quote>nulls sort low</> behavior, rather than the default <quote>nulls
   sort high</>, in queries that depend on indexes to avoid sorting steps.
  </para>

  <para>
   For most index methods, the speed of creating an index is
   dependent on the setting of <xref linkend="guc-maintenance-work-mem">.
   Larger values will reduce the time needed for index creation, so long
   as you don't make it larger than the amount of memory really available,
   which would drive the machine into swapping.
  </para>

  <para>
   Use <xref linkend="sql-dropindex">
   to remove an index.
  </para>

  <para>
   Prior releases of <productname>PostgreSQL</productname> also had an
   R-tree index method.  This method has been removed because
   it had no significant advantages over the GiST method.
   If <literal>USING rtree</> is specified, <command>CREATE INDEX</>
   will interpret it as <literal>USING gist</>, to simplify conversion
   of old databases to GiST.
  </para>
 </refsect1>

 <refsect1>
  <title>예제</title>

  <para>
   To create a B-tree index on the column <literal>title</literal> in
   the table <literal>films</literal>:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title);
</programlisting>
  </para>

  <para>
   To create an index on the expression <literal>lower(title)</>,
   allowing efficient case-insensitive searches:
<programlisting>
CREATE INDEX ON films ((lower(title)));
</programlisting>
   (In this example we have chosen to omit the index name, so the system
   will choose a name, typically <literal>films_lower_idx</>.)
  </para>

  <para>
   To create an index with non-default collation:
<programlisting>
CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");
</programlisting>
  </para>

  <para>
   To create an index with non-default sort ordering of nulls:
<programlisting>
CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);
</programlisting>
  </para>

  <para>
   To create an index with non-default fill factor:
<programlisting>
CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);
</programlisting>
  </para>

  <para>
   To create a <acronym>GIN</> index with fast updates disabled:
<programlisting>
CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);
</programlisting>
  </para>

  <para>
   To create an index on the column <literal>code</> in the table
   <literal>films</> and have the index reside in the tablespace
   <literal>indexspace</>:
<programlisting>
CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;
</programlisting>
  </para>

  <para>
   To create a GiST index on a point attribute so that we
   can efficiently use box operators on the result of the
   conversion function:
<programlisting>
CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;
</programlisting>
  </para>

  <para>
   To create an index without locking out writes to the table:
<programlisting>
CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);
</programlisting></para>

 </refsect1>

 <refsect1>
  <title>호환성</title>

  <para>
   <command>CREATE INDEX</command> is a
   <productname>PostgreSQL</productname> language extension.  There
   are no provisions for indexes in the SQL standard.
  </para>
 </refsect1>

 <refsect1>
  <title>관련 항목</title>

  <simplelist type="inline">
   <member><xref linkend="sql-alterindex"></member>
   <member><xref linkend="sql-dropindex"></member>
  </simplelist>
 </refsect1>
</refentry>
