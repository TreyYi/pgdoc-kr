<!-- doc/src/sgml/maintenance.sgml -->

<chapter id="maintenance">
 <title>정기적인 데이터베이스 관리 작업들</title>

 <indexterm zone="maintenance">
  <primary>관리</primary>
 </indexterm>

 <indexterm zone="maintenance">
  <primary>정기 관리</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</>, like any database software, requires that certain tasks
   be performed regularly to achieve optimum performance. The tasks
   discussed here are <emphasis>required</emphasis>, but they
   are repetitive in nature and can easily be automated using standard
   tools such as <application>cron</application> scripts or
   Windows' <application>Task Scheduler</>.  It is the database
   administrator's responsibility to set up appropriate scripts, and to
   check that they execute successfully.
  </para>

  <para>
   One obvious maintenance task is the creation of backup copies of the data on a
   regular schedule.  Without a recent backup, you have no chance of recovery
   after a catastrophe (disk failure, fire, mistakenly dropping a critical
   table, etc.).  The backup and recovery mechanisms available in
   <productname>PostgreSQL</productname> are discussed at length in
   <xref linkend="backup">.
  </para>

  <para>
   The other main category of maintenance task is periodic <quote>vacuuming</>
   of the database.  This activity is discussed in
   <xref linkend="routine-vacuuming">.  Closely related to this is updating
   the statistics that will be used by the query planner, as discussed in
   <xref linkend="vacuum-for-statistics">.
  </para>

  <para>
   Another task that might need periodic attention is log file management.
   This is discussed in <xref linkend="logfile-maintenance">.
  </para>

  <para>
   <ulink
   url="http://bucardo.org/wiki/Check_postgres"><application>check_postgres</></ulink>
   is available for monitoring database health and reporting unusual
   conditions.  <application>check_postgres</> integrates with
   Nagios and MRTG, but can be run standalone too.
  </para>

  <para>
   <productname>PostgreSQL</productname> is low-maintenance compared
   to some other database management systems.  Nonetheless,
   appropriate attention to these tasks will go far towards ensuring a
   pleasant and productive experience with the system.
  </para>

 <sect1 id="routine-vacuuming">
  <title>정기적인 Vacuum 작업</title>

  <indexterm zone="routine-vacuuming">
   <primary>vacuum</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> 데이터베이스에서는 
   <firstterm>vacuum</> (배큠이라고 읽는다) 이라는 주기적인
   관리 작업이 필요하다.  (영어권에서는 vacuuming 단어는 
   '청소기 돌리기'라는 뜻으로 이미 생활 용어로 사용되고 있고, 
   이것을 데이터베이스 용어로 사용하였다.  이 글에서는 그냥 
   vacuum을 그대로 사용한다. - 옮긴이)
   이 작업은 대부분의 서버 환경에서는 <firstterm>autovacuum 데몬</>이
   담당해서 자동으로 처리 되기 때문에, 특별히 신경 쓸 필요는 없다. 
   이 부분은 <xref linkend="autovacuum">에서 자세히 소개한다.  
   autovacuum 관련 환경 설정값을 바꾸어서 그 데몬의 동작 상태를 
   조절 할 수 있다.  또한 몇몇 데이터베이스
   관리자는 <command>VACUUM</> 명령을 직접 실행하는 것이 데이터베이스를
   효율적으로 사용할 수 있다고 판단해서, <application>cron</application>
   이나, <application>작업 스케줄러</> 같은 프로그램을 이용해서, 
   이런 주기적인 정리 작업을 한다.  이런 작업을 잘 하기 위해서는 
   여기서 설명하고 있는 내용을 잘 이해하고 있어야한다.  
   autovacuum 기능을 이용하는 일반적인 환경에서 
   특별히 문제가 발생하지 않는다면, 게다가 다른 바쁜 일들이 많은 
   관리자라면 이 부분은 대충 읽어도 좋다.
  </para>

  <sect2 id="vacuum-basics">
   <title>Vacuum 기초</title>

   <para>
    <productname>PostgreSQL</productname>에서
    <xref linkend="sql-vacuum"> 명령은 다음과 같은 여러 가지 이유로
    정기적으로 각 테이블 단위로 실행되어야 한다:

    <orderedlist>
     <listitem>
      <simpara>변경 또는 삭제된 자료들이 차지 하고 있는 
      디스크 공간을 다시 사용하기 위한 디스크 공간 확보 작업이 필요하다.
      </simpara>
     </listitem>

     <listitem>
      <simpara><productname>PostgreSQL</productname>
      쿼리 실행 계획기가 사용할 자료 통계 정보를 갱신할 필요가 있다.
      </simpara>
     </listitem>

     <listitem>
      <simpara>인덱스 전용 검색 성능을 향상하는데 이용하는 
      실자료 지도(visibility map, vm) 정보를 갱신하는 작업이 필요하다.
      </simpara>
     </listitem>

     <listitem>
      <simpara><firstterm>트랜잭션 ID 겹침</>이나,
      <firstterm>다중 트랙잭션 ID 겹침</> 상황으로
      오래된 자료가 손실 될 가능성을 방지해야할 필요가 있다.
      </simpara>
     </listitem>
    </orderedlist>

    이런 이유로 <command>VACUUM</> 작업은 그 작업 이유에 맞게
    다양한 주기로, 다양한 대상으로 진행된다.  이 부분에 대한 자세한 설명은
    이 글의 하위 항목에서 각각 설명한다.
   </para>

   <para>
    <command>VACUUM</> 작업은 두 가지 종류가 있다: 표준 <command>VACUUM</>과
    <command>VACUUM FULL</>이다. <command>VACUUM FULL</> 작업은 
    물리적인 디스크 여유 공간을 확보할 수 있으나 그 작업 속도가 매우 느리다.
    하지만 표준 <command>VACUUM</> 작업은 운영 환경에서도 사용할 수 있도록
    여러 다른 작업들(<command>SELECT</command>,
    <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command> 이런 명령어로 수행되는 작업들)이 실행 되고 
    있어도 동시에 사용할 수 있다. (하지만, <command>ALTER TABLE</command>
    명령과 같은 명령은 VACUUM 작업이 실행되고 있는 상황에서는 사용할 수 없다.)
    <command>VACUUM FULL</> 명령은 해당 테이블에 대한 
    배타적 잠금(exclusive lock)을 지정하기 때문에, 
    어떤 작업도 할 수 없게 된다.
    이렇기 때문에, 일반적 상황에서는 관리자는 <command>VACUUM FULL</> 작업을
    되도록이면 피하고, 표준 <command>VACUUM</> 작업을 하겠끔 신경 써야한다.
   </para>

   <para>
    <command>VACUUM</command> 작업은 추가적으로 디스크 입출력 부하를 
    만든다. 이 때문에 동시에 작업하고 있는 다른 세션의 성능을 
    떨어뜨린다. 이 부분은 <xref linkend="runtime-config-resource-vacuum-cost">
    에서 소개하고 있는 VACUUM 작업의 비용 조절 관련 환경 설정 변경으로 
    어느 정도는 조절이 가능하다.
   </para>
  </sect2>

  <sect2 id="vacuum-for-space-recovery">
   <title>디스크 여유 공간 확보</title>

   <indexterm zone="vacuum-for-space-recovery">
    <primary>디스크 여유 공간</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname>에서는
    <command>UPDATE</>나 <command>DELETE</> 작업 대상이 
    된 해당 자료의 변경, 삭제 이전 자료를 작업 완료 후
    바로 버리지 않는다.  이 작업은 
    다중 버전 동시성 제어(multiversion
    concurrency control, <acronym>MVCC</> - <xref linkend="mvcc"> 참조) 기법을 
    구현하는데 이점이 있기 때문이다. 
    삭제된 자료를 다른 트랜잭션에서 사용하고 있다면, 
    그 자료가 삭제되면 안되기 때문이다. 
    하지만, 다른 트랜잭션이 더 이상이 그 변경, 삭제 이전 자료에 대한 접근이 
    필요 없다면, 쓸모 없는 자료가 남아있게 된다.  이 상태로 계속 운영 된다면,
    디스크에는 쓸모 없는 자료들이 넘처나게 될 것이다.  이런 더 이상 사용할 수 
    없는, 사용해서는 안될 자료들을 정리해서 그 자료가 있었던 공간을 빈 공간으로
    바꾸는 작업을 <command>VACUUM</> 작업이 수행한다.
   </para>

   <para>
    <command>VACUUM</command> 기본 작업은 
    테이블과 인덱스에서 삭제된 자료 (old version row, dead row 라고 한다)
    를 정리하고, 그 자리를 다른 자료가 저장 될 수 있도록 빈공간으로 
    표시하는 것이다.
    하지만, 이 작업은 운영체제 입장에서의 디스크 여유 공간을 확보하는 것을
    의미하지는 않는다. 물론 한 테이블의 자료가 모두 지워졌고, 
    하나 또는 소수의 페이지만 없애면 되는데, 이 작업을 위해 테이블 전체의
    배타적 잠금도 쉽게 할 수 있는 상황과 같이 특별한 경우는 
    해당 페이지를 삭제 해서 운영체제 입장의 디스크 여유 공간을 확보할 수
    있기도 한다.  이와 반대로, <command>VACUUM FULL</> 작업은
    해당 테이블의 사용할 수 있는 자료들만을 따로 모아 아에 새 파일에 
    저장하는 방식을 이용하기 때문에 운영체제 입장에서 디스크 여유 
    공간을 확보할 수 있다.  작업 결과로 해당 테이블에 대해서
    최적의 물리적 크기로 테이블이 만들어진다.  하지만 
    그 작업은 일반 VACUUM 작업에 비해 시간이 꽤 걸린다.  또한 이 작업이
    완료되기 전까지 이 작업을 할 수 있는 여유 공간이 있어야 작업을 할 수
    있다.
   </para>

   <para>
    일반적인 vacuum 전략은 주기적인 표준 <command>VACUUM</> 작업을 
    해서, 꾸준히 빈 공간을 확보해서 디스크가 어느 정도 커지지만, 
    더 이상 크지지 않게 해서, 최대한 <command>VACUUM FULL</>
    이런 전략은 autovacuum 데몬이 이런 전략으로 작업을 한다.
    즉, autovacuum 기능을 사용한다면, <command>VACUUM FULL</>
    작업을 하지 않는 것을 기본 정책으로 하면 된다.
    이런 전략은 각 테이블이 최소의 디스크 공간을 사용한다는 것을 
    의미하는 것이 아니라, 최적의 디스크 공간을 사용함을 의미한다.
    각 테이블은 실재 자료가 저장되어 있는 공간과 함께 vacuum 작업으로 
    처리된 빈공간을 함께 사용함을 의미한다. 
    반면, 어떤 테이블은 더이상 변경, 삭제 작업이 없어, 
    최소의 디스크 공간만 사용하면 된다고 판단되면, <command>VACUUM FULL</>
    명령을 이용할 수도 있을 것이다.  이렇게 해서, 쓸모 없는 공간을
    운영체제 쪽으로 반환할 수도 있다.
    종합하면, 대용량 테이블을 관리하는 입장에서 보면, 
    비정기적인 <command>VACUUM FULL</> 작업보다, 
    정기적인 표준 <command>VACUUM</> 작업이 운영상 더 낫다.
   </para>

   <para>
    어떤 관리자는 vacuum 작업을 사용량이 적은 밤 시간에 주기적으로 
    작업 하도록 직접 관리하려고 한다.  이렇게 특정 시간에 vacuum 작업을
    할 때는 갑자기 자료 변경이 많은 작업이 생겨, 디스크 공간을 많이
    쓰게 되는 경우도 함께 고려되어야 한다.  최악의 경우는 디스크 공간이 
    모자라 <command>VACUUM FULL</> 작업을 선택해야 할 경우도 생기기 때문이다. 
    autovacuum 데몬을 이용하면, 이런 예상치 못한 상황에 대해서도 자동으로 
    vacuum 작업이 진행되어 위와 같은 문제들을 피해갈 수 있다.  정확한 
    데이터베이스 사용량을 파악하지 않고 그냥 autovacuum 기능을 끄는 것은 
    현명하지 못한 선택이다.  한 타협점은 이 데몬의 실행 환경 설정값을 변경해서
    예상치 못한 대량 변경 작업에 대해서만 vacuum 작업이 자동으로 실행 되겠끔
    하는 것이다. 그래서, 주기적인 관리자 정의 <command>VACUUM</>
    작업을 유지하면서, 예외 상황에 대해서 자동으로 대처하도록 하는 것도
    한 방법이 될 것이다.
   </para>

   <para>
    autovacuum 기능을 사용하지 않는다면, 주의해야할 점은 
    해당 데이터베이스 서버에서 사용하고 있는 모든 데이터베이스에 대해서
    <command>VACUUM</> 작업을 해야한다는 것이다.  일반적으로
    하루에 한 번 밤시간에 지정하는 것이 일반적이며, 
    자료가 빈번하게 변경되는 테이블에 대해서는 더 자주 vacuum 작업 하도록
    설정한다. (아주 빈번한 테이블에 대해서 몇 분에 한 번씩 작업 하도록
    설정해야할 필요도 있을 것이다.)
    각 데이터베이스별 vacuum 작업을 할 때  <xref
    linkend="app-vacuumdb"> 응용 프로그램을 이용하면 도움이 될 것이다.
   </para>

   <tip>
   <para>
    일반적인 <command>VACUUM</> 작업은 해당 테이블 전체를 대상으로 하는 
    변경 작업이나, 삭제 작업과 같은 대량의 작업에 대해서는
    만족할 만한 결과를 제공하지는 않는다.  이런 경우, 디스크 여유 
    공간을 확보해야 할 필요성이 있다면, <command>VACUUM FULL</>
    명령이나, <xref linkend="sql-cluster"> 또는
    <xref linkend="sql-altertable"> 명령(CLUSTER ON 옵션)을 이용해서, 
    테이블을 아에 새롭게 만드는 방법을 선택할 수 있다.
    이들 명령을 사용할 때는 반드시 주의해야할 사항은 
    이들 명령은 테이블 대상으로 배타적 잠금을 한다는 점이다.
    즉, 이 작업이 완료되기 전까지 그 테이블을 대상으로 하는 
    다른 모든 작업들을 다른 세션에서는 할 수 없게 됨을 염두해 
    두어야 하며, 이들 작업은 작업 도중 원본과 다른 새로운 복사본
    자료를 만들기 때문에 그만큼의 디스크 공간이 필요하다는 것도
    기억하고 있어야 한다.
   </para>
   </tip>

   <tip>
   <para>
    테이블의 모든 자료를 아에 지워버리고자 한다면, 
    <command>DELETE</command> 명령보다는 
    <xref linkend="sql-truncate"> 명령을 사용하는 것이 
    낫다. 이 명령은 작업 뒤에, <command>VACUUM</command> 이나
    <command>VACUUM FULL</command> 명령을 사용할 필요가 없다.
    단, 이 명령을 사용하게 되면 MVCC 대상에서 제외되기 때문에, 
    다중 세션 다중 트랜잭션 환경에서는 위험하다.
   </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-statistics">
   <title>실행계획 통계정보 갱신</title>

   <indexterm zone="vacuum-for-statistics">
    <primary>통계정보</primary>
    <secondary>쿼리 실행계획기</secondary>
   </indexterm>

   <indexterm zone="vacuum-for-statistics">
    <primary>ANALYZE</primary>
   </indexterm>

   <para>
    <productname>PostgreSQL</productname> 쿼리 실행 계획기는 
    쿼리의 좋은 실행 계획을 짜기 위해서 각 테이블에 저장된 자료를 바탕으로
    수집된 통계 정보를 이용한다.  이 통계 정보는 
    <xref linkend="sql-analyze"> 명령을 이용해서 만든다.
    또한 <command>VACUUM</> 명령을 수행하면서 옵션으로 이 작업을 할 수 있다.
    이 통계 정보 갱신 작업이 제대로 되지 않으면 의도 되지 않은 쿼리 실행 계획이
    짜여질 것이고, 이것으로 전체적으로 데이터베이스 성능을 떨어뜨리는 
    결과를 초래하기 때문에, 바른 통계 정보 갱신 작업을 주기적으로 
    하는 것은 중요하다.
   </para>

   <para>
    autovacuum 기능을 이용한다면, 통계 정보를 갱신해야할 필요성이 있는
    테이블들에 대해서 주기적으로 <command>ANALYZE</> 명령을 자동으로 수행한다.
    반면, 자료 변경 작업이 어떤 칼럼에 일어나고, 그 변경 작업 때문에, 
    통계 정보를 갱신해서, 실행 계획이 잘 짜여지는 것과 관련 없다고
    명확하게 판단되는 경우라면, 관리자는 이 통계 정보 갱신 작업을 
    직접 수행하거나, 아에 안할 수도 있습니다.  autovacuum 데몬은 
    이런 세세한 경우까지는 고려하지 않고, 테이블의 자료가 새로 추가 되었거나,
    변경, 삭제 된 경우라면, 무조건 통계 정보 갱신 작업의 고려 대상이 
    된다고 판단한다.
   </para>

   <para>
    통계 정보 갱신 작업도 디스크 여유 공간 확보를 위한 vacuum 작업과 
    마찬가지로 테이블의 자료 변화량이 많은 경우는 보다 빈번하게, 
    그 반대인 경우는 좀 더 드물게 진행됨이 좋다.
    물론, 테이블의 자료가 빈번하게 변경된다고 하더라도, 
    그 변경 내용이 수집할 통계 정보와 관련 없는 것이라면, 
    당연히 통계 정보 갱신 작업이 필요 없다. 
    통계 정보를 갱신 할 빈도를 추측하는 가장 간단한 방법은 
    그 칼럼의 최소값과 최대값이 얼마나 자주 바뀌느냐를 살펴보는 것이다.
    예를 들어 웹서비스에서 각 페이지의 마지막 접근 정보를 기록하는
    테이블을 고려해 본다면, 마지막 접근 시각을 기록하는 
    <type>timestamp</type> 자료형의 칼럼은 URL을 담고 있는 칼럼보다 
    훨씬 빈번하게 변경될 것이다.  따라서 URL 정보의 통계 정보 갱신 작업보다
    마지막 접근 시각의 통계 정보 갱신이 더 빈번하게 일어나야
    보다 정확한 실행 계획이 짜여질 것이다.
   </para>

   <para>
    <command>ANALYZE</> 명령을 사용자가 직접 실행 할 때는, 
    한 테이블의 특정 칼럼 정보에 대해서만 통계 정보를 갱신하도록 할 수 있다.
    이렇게 함으로 위에서 언급한 것 처럼 칼럼별 통계 정보 갱신 작업 빈도를 
    칼럼별로 조절할 수 있다.  하지만, 운영 환경에서는 일반적으로
    데이터베이스 전체를 대상으로 이 작업을 한다. 왜냐하면, 
    기본적으로 자료 통계 정보 갱신 작업은 전체 자료를 대상으로 하지 않고, 
    임의의 샘플 자료만을 대상으로 하기 때문에, 꽤 빨리 작업이 끝난다.
   </para>

   <tip>
    <para>
     칼럼 단위로 <command>ANALYZE</> 작업을 한다는 것이 운영 환경에서 
     사용하기에는 번거로운 일이긴 하지만, 보다 정확한 통계 정보를 
     싼 비용으로 갱신 할 수 있다는 점에서 장점이 있다.
     예를 들어 한 칼럼의 자료 분포가 아주 넓고, 그 칼럼이 <literal>WHERE</>
     절의 조건 검색으로 자주 사용된다면, 이 칼럼의 통계 정보는 
     다른 칼럼보다 더 꼼꼼하게 관리되는 것이 좋을 것이다. 
     이런 경우, <command>ALTER TABLE SET STATISTICS</> 명령을 통해
     해당 테이블의 개별 통계 수집 설정값을 바꾸어서 꼼꼼하게 관리 할 수 
     있다.  또한 서버 환경 설정인  <xref
     linkend="guc-default-statistics-target"> 값을 조정해서 데이터베이스
     전체를 대상으로 조절할 수도 있다.
    </para>

    <para>
     또한, 함수 사용에 대한 통계 정보는 기본적으로 제한된 정보만 제공 한다. 
     하지만, 함수 기반 인덱스를 만들었다면, 
     이 부분에 대해서는 통계 정보 갱신 작업이 함수 반환값을 대상으로 이루워
     지기 때문에, 검색 조건으로 인덱스를 만들 때와 같이 해당 칼럼에 해당 
     함수를 사용하다면 쿼리 실행 계획기는 바르게 실행 계획을 짤 것이다.
    </para>
   </tip>

   <tip>
    <para>
     autovacuum 데몬은 외부 테이블(foreign table)에 대해서는 
     <command>ANALYZE</> 작업을 하지 않는다.  외부 테이블을 사용하고, 
     그것의 통계 정보가 갱신 될 필요성이 있다면, 
     직접 <command>ANALYZE</> 명령을 주기적으로 실행해야 할 것이다.
    </para>
   </tip>
  </sect2>

  <sect2 id="vacuum-for-visibility-map">
   <title>실자료 지도 갱신</title>

   <para>
    vacuum 작업은 <link linkend="storage-vm">실자료 지도</>를 갱신하는 작업을 한다.
    실자료 지도(visibility map, vm)란 현재 작업 중인 트랜잭션들(또는 그 자료들이
    변경 되기 전까지 이용할 미래의 모든 트랜잭션들)이 실제로 사용할 자료들에 대한
    각 테이블별 지도다.  이 작업은 두가지 목적이 있다. 하나는 vacuum 작업은 
    이미 지도 정리 작업이 끝난 것에 대해서는 더 이상 그 작업을 하지 않는다는 것이다.
   </para>

   <para>
    다른 하나는, 이 지도 정보는 인덱스 전용 쿼리들 - 더 이상 실제 테이블 자료를 
    검사 하지 않는 쿼리들 - 에 대해서 빠르게 작동하기 위해서다.
    <productname>PostgreSQL</productname>의 인덱스에는 실자료들에 대해서만 따로
    모아서 그 정보를 제공하지 않는다. 즉, 어떤 자료를 해당 세션에게 보여 주어야 
    할지를 결정 하는 정보는 그 자료의 테이블 페이지까지 살펴 보아야 알 수 있다. 
    <firstterm>인덱스 전용 검색</>인 경우는 테이블 페이지를 검색하지 않고, 
    먼저 이 실자료 지도를 검색해서, 이곳에 해당 자료가 있다면, 그것을 사용한다.
    그만큼 테이블 페이지 읽기 작업을 줄일 수 있는 있다.  특히나 테이블 크기가
    큰 경우라면, 디스크 읽기 작업을 상당히 줄이는 효과를 볼 수 있다. 
    왜냐하면, 실제 테이블 페이지 보다, 이 실자료 지도의 크기는 훨씬 작기 때문이다.
   </para>
  </sect2>

  <sect2 id="vacuum-for-wraparound">
   <title>트랜잭션 ID 겹침 오류 방지</title>

   <indexterm zone="vacuum-for-wraparound">
    <primary>트랜잭션 ID</primary>
    <secondary>겹침</secondary>
   </indexterm>

    <indexterm>
     <primary>겹침</primary>
     <secondary>트랜잭션 ID</secondary>
    </indexterm>

   <para>
    <productname>PostgreSQL</productname>'s MVCC transaction semantics
    depend on being able to compare transaction ID (<acronym>XID</>)
    numbers: a row version with an insertion XID greater than the current
    transaction's XID is <quote>in the future</> and should not be visible
    to the current transaction.  But since transaction IDs have limited size
    (32 bits) a cluster that runs for a long time (more
    than 4 billion transactions) would suffer <firstterm>transaction ID
    wraparound</>: the XID counter wraps around to zero, and all of a sudden
    transactions that were in the past appear to be in the future &mdash; which
    means their output become invisible.  In short, catastrophic data loss.
    (Actually the data is still there, but that's cold comfort if you cannot
    get at it.)  To avoid this, it is necessary to vacuum every table
    in every database at least once every two billion transactions.
   </para>

   <para>
    The reason that periodic vacuuming solves the problem is that
    <productname>PostgreSQL</productname> reserves a special XID
    as <literal>FrozenXID</>.  This XID does not follow the normal XID
    comparison rules and is always considered older
    than every normal XID. Normal XIDs are
    compared using modulo-2<superscript>32</> arithmetic. This means
    that for every normal XID, there are two billion XIDs that are
    <quote>older</> and two billion that are <quote>newer</>; another
    way to say it is that the normal XID space is circular with no
    endpoint. Therefore, once a row version has been created with a particular
    normal XID, the row version will appear to be <quote>in the past</> for
    the next two billion transactions, no matter which normal XID we are
    talking about. If the row version still exists after more than two billion
    transactions, it will suddenly appear to be in the future. To
    prevent this, old row versions must be reassigned the XID
    <literal>FrozenXID</> sometime before they reach the
    two-billion-transactions-old mark. Once they are assigned this
    special XID, they will appear to be <quote>in the past</> to all
    normal transactions regardless of wraparound issues, and so such
    row versions will be valid until deleted, no matter how long that is.
    This reassignment of old XIDs is handled by <command>VACUUM</>.
   </para>

   <para>
    <xref linkend="guc-vacuum-freeze-min-age">
    controls how old an XID value has to be before it's replaced with
    <literal>FrozenXID</>.  Larger values of this setting
    preserve transactional information longer, while smaller values increase
    the number of transactions that can elapse before the table must be
    vacuumed again.
   </para>

   <para>
    <command>VACUUM</> normally skips pages that don't have any dead row
    versions, but those pages might still have row versions with old XID
    values.  To ensure all old XIDs have been replaced by
    <literal>FrozenXID</>, a scan of the whole table is needed.
    <xref linkend="guc-vacuum-freeze-table-age"> controls when
    <command>VACUUM</> does that: a whole table sweep is forced if
    the table hasn't been fully scanned for <varname>vacuum_freeze_table_age</>
    minus <varname>vacuum_freeze_min_age</> transactions. Setting it to 0
    forces <command>VACUUM</> to always scan all pages, effectively ignoring
    the visibility map.
   </para>

   <para>
    The maximum time that a table can go unvacuumed is two billion
    transactions minus the <varname>vacuum_freeze_min_age</> value at
    the time <command>VACUUM</> last scanned the whole table.  If it were to go
    unvacuumed for longer than
    that, data loss could result.  To ensure that this does not happen,
    autovacuum is invoked on any table that might contain XIDs older than the
    age specified by the configuration parameter <xref
    linkend="guc-autovacuum-freeze-max-age">.  (This will happen even if
    autovacuum is disabled.)
   </para>

   <para>
    This implies that if a table is not otherwise vacuumed,
    autovacuum will be invoked on it approximately once every
    <varname>autovacuum_freeze_max_age</> minus
    <varname>vacuum_freeze_min_age</> transactions.
    For tables that are regularly vacuumed for space reclamation purposes,
    this is of little importance.  However, for static tables
    (including tables that receive inserts, but no updates or deletes),
    there is no need to vacuum for space reclamation, so it can
    be useful to try to maximize the interval between forced autovacuums
    on very large static tables.  Obviously one can do this either by
    increasing <varname>autovacuum_freeze_max_age</> or decreasing
    <varname>vacuum_freeze_min_age</>.
   </para>

   <para>
    The effective maximum for <varname>vacuum_freeze_table_age</> is 0.95 *
    <varname>autovacuum_freeze_max_age</>; a setting higher than that will be
    capped to the maximum. A value higher than
    <varname>autovacuum_freeze_max_age</> wouldn't make sense because an
    anti-wraparound autovacuum would be triggered at that point anyway, and
    the 0.95 multiplier leaves some breathing room to run a manual
    <command>VACUUM</> before that happens.  As a rule of thumb,
    <command>vacuum_freeze_table_age</> should be set to a value somewhat
    below <varname>autovacuum_freeze_max_age</>, leaving enough gap so that
    a regularly scheduled <command>VACUUM</> or an autovacuum triggered by
    normal delete and update activity is run in that window.  Setting it too
    close could lead to anti-wraparound autovacuums, even though the table
    was recently vacuumed to reclaim space, whereas lower values lead to more
    frequent whole-table scans.
   </para>

   <para>
    The sole disadvantage of increasing <varname>autovacuum_freeze_max_age</>
    (and <varname>vacuum_freeze_table_age</> along with it)
    is that the <filename>pg_clog</> subdirectory of the database cluster
    will take more space, because it must store the commit status of all
    transactions back to the <varname>autovacuum_freeze_max_age</> horizon.
    The commit status uses two bits per transaction, so if
    <varname>autovacuum_freeze_max_age</> is set to its maximum allowed
    value of two billion, <filename>pg_clog</> can be expected to
    grow to about half a gigabyte.  If this is trivial compared to your
    total database size, setting <varname>autovacuum_freeze_max_age</> to
    its maximum allowed value is recommended.  Otherwise, set it depending
    on what you are willing to allow for <filename>pg_clog</> storage.
    (The default, 200 million transactions, translates to about 50MB of
    <filename>pg_clog</> storage.)
   </para>

   <para>
    One disadvantage of decreasing <varname>vacuum_freeze_min_age</> is that
    it might cause <command>VACUUM</> to do useless work: changing a table row's
    XID to <literal>FrozenXID</> is a waste of time if the row is modified
    soon thereafter (causing it to acquire a new XID).  So the setting should
    be large enough that rows are not frozen until they are unlikely to change
    any more.  Another disadvantage of decreasing this setting is
    that details about exactly which transaction inserted or modified a
    row will be lost sooner.  This information sometimes comes in handy,
    particularly when trying to analyze what went wrong after a database
    failure.  For these two reasons, decreasing this setting is not
    recommended except for completely static tables.
   </para>

   <para>
    To track the age of the oldest XIDs in a database,
    <command>VACUUM</> stores XID
    statistics in the system tables <structname>pg_class</> and
    <structname>pg_database</>.  In particular,
    the <structfield>relfrozenxid</> column of a table's
    <structname>pg_class</> row contains the freeze cutoff XID that was used
    by the last whole-table <command>VACUUM</> for that table.  All normal
    XIDs older than this cutoff XID are guaranteed to have been replaced by
    <literal>FrozenXID</> within the table.  Similarly,
    the <structfield>datfrozenxid</> column of a database's
    <structname>pg_database</> row is a lower bound on the normal XIDs
    appearing in that database &mdash; it is just the minimum of the
    per-table <structfield>relfrozenxid</> values within the database.
    A convenient way to
    examine this information is to execute queries such as:

<programlisting>
SELECT c.oid::regclass as table_name,
       greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind IN ('r', 'm');

SELECT datname, age(datfrozenxid) FROM pg_database;
</programlisting>

    The <literal>age</> column measures the number of transactions from the
    cutoff XID to the current transaction's XID.
   </para>

   <para>
    <command>VACUUM</> normally
    only scans pages that have been modified since the last vacuum, but
    <structfield>relfrozenxid</> can only be advanced when the whole table is
    scanned. The whole table is scanned when <structfield>relfrozenxid</> is
    more than <varname>vacuum_freeze_table_age</> transactions old, when
    <command>VACUUM</>'s <literal>FREEZE</> option is used, or when all pages
    happen to
    require vacuuming to remove dead row versions. When <command>VACUUM</>
    scans the whole table, after it's finished <literal>age(relfrozenxid)</>
    should be a little more than the <varname>vacuum_freeze_min_age</> setting
    that was used (more by the number of transactions started since the
    <command>VACUUM</> started).  If no whole-table-scanning <command>VACUUM</>
    is issued on the table until <varname>autovacuum_freeze_max_age</> is
    reached, an autovacuum will soon be forced for the table.
   </para>

   <para>
    If for some reason autovacuum fails to clear old XIDs from a table,
    the system will begin to emit warning messages like this when the
    database's oldest XIDs reach ten million transactions from the wraparound
    point:

<programlisting>
WARNING:  database "mydb" must be vacuumed within 177009986 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in "mydb".
</programlisting>

    (A manual <command>VACUUM</> should fix the problem, as suggested by the
    hint; but note that the <command>VACUUM</> must be performed by a
    superuser, else it will fail to process system catalogs and thus not
    be able to advance the database's <structfield>datfrozenxid</>.)
    If these warnings are
    ignored, the system will shut down and refuse to start any new
    transactions once there are fewer than 1 million transactions left
    until wraparound:

<programlisting>
ERROR:  database is not accepting commands to avoid wraparound data loss in database "mydb"
HINT:  Stop the postmaster and use a standalone backend to VACUUM in "mydb".
</programlisting>

    The 1-million-transaction safety margin exists to let the
    administrator recover without data loss, by manually executing the
    required <command>VACUUM</> commands.  However, since the system will not
    execute commands once it has gone into the safety shutdown mode,
    the only way to do this is to stop the server and use a single-user
    backend to execute <command>VACUUM</>.  The shutdown mode is not enforced
    by a single-user backend.  See the <xref linkend="app-postgres"> reference
    page for details about using a single-user backend.
   </para>

   <sect3 id="vacuum-for-multixact-wraparound">
    <title>다중 트랜잭션과 겹침</title>

    <indexterm>
     <primary>MultiXactId</primary>
    </indexterm>

    <indexterm>
     <primary>겹침</primary>
     <secondary>다중 트랜잭션</secondary>
    </indexterm>

    <para>
     <firstterm>Multixact IDs</> are used to support row locking by
     multiple transactions.  Since there is only limited space in a tuple
     header to store lock information, that information is encoded as
     a <quote>multiple transaction ID</>, or multixact ID for short,
     whenever there is more than one transaction concurrently locking a
     row.  Information about which transaction IDs are included in any
     particular multixact ID is stored separately in
     the <filename>pg_multixact</> subdirectory, and only the multixact ID
     appears in the <structfield>xmax</> field in the tuple header.
     Like transaction IDs, multixact IDs are implemented as a
     32-bit counter and corresponding storage, all of which requires
     careful aging management, storage cleanup, and wraparound handling.
    </para>

    <para>
     During a <command>VACUUM</> table scan, either partial or of the whole
     table, any multixact ID older than
     <xref linkend="guc-vacuum-multixact-freeze-min-age">
     is replaced by a different value, which can be the zero value, a single
     transaction ID, or a newer multixact ID.  For each table,
     <structname>pg_class</>.<structfield>relminmxid</> stores the oldest
     possible multixact ID still appearing in any tuple of that table.
     If this value is older than
     <xref linkend="guc-vacuum-multixact-freeze-table-age">, a whole-table
     scan is forced.  Whole-table <command>VACUUM</> scans, regardless of
     what causes them, enable advancing the value for that table.
     Eventually, as all tables in all databases are scanned and their
     oldest multixact values are advanced, on-disk storage for older
     multixacts can be removed.
    </para>

    <para>
     As a safety device, a whole-table vacuum scan will occur for any table
     whose multixact-age is greater than
     <xref linkend="guc-autovacuum-multixact-freeze-max-age">.
     This will occur even if autovacuum is nominally disabled.
    </para>
   </sect3>
  </sect2>

  <sect2 id="autovacuum">
   <title>Autovacuum 데몬</title>

   <indexterm>
    <primary>autovacuum</primary>
    <secondary>일반 정보</secondary>
   </indexterm>
   <para>
    <productname>PostgreSQL</productname> has an optional but highly
    recommended feature called <firstterm>autovacuum</firstterm>,
    whose purpose is to automate the execution of
    <command>VACUUM</command> and <command>ANALYZE </command> commands.
    When enabled, autovacuum checks for
    tables that have had a large number of inserted, updated or deleted
    tuples.  These checks use the statistics collection facility;
    therefore, autovacuum cannot be used unless <xref
    linkend="guc-track-counts"> is set to <literal>true</literal>.
    In the default configuration, autovacuuming is enabled and the related
    configuration parameters are appropriately set.
   </para>

   <para>
    The <quote>autovacuum daemon</> actually consists of multiple processes.
    There is a persistent daemon process, called the
    <firstterm>autovacuum launcher</firstterm>, which is in charge of starting
    <firstterm>autovacuum worker</firstterm> processes for all databases. The
    launcher will distribute the work across time, attempting to start one
    worker within each database every <xref linkend="guc-autovacuum-naptime">
    seconds.  (Therefore, if the installation has <replaceable>N</> databases,
    a new worker will be launched every
    <varname>autovacuum_naptime</>/<replaceable>N</> seconds.)
    A maximum of <xref linkend="guc-autovacuum-max-workers"> worker processes
    are allowed to run at the same time. If there are more than
    <varname>autovacuum_max_workers</> databases to be processed,
    the next database will be processed as soon as the first worker finishes.
    Each worker process will check each table within its database and
    execute <command>VACUUM</> and/or <command>ANALYZE</> as needed.
    <varname>log_autovacuum_min_duration</varname> can be used to monitor
    autovacuum activity.
   </para>

   <para>
    If several large tables all become eligible for vacuuming in a short
    amount of time, all autovacuum workers might become occupied with
    vacuuming those tables for a long period.  This would result
    in other tables and databases not being vacuumed until a worker became
    available. There is no limit on how many workers might be in a
    single database, but workers do try to avoid repeating work that has
    already been done by other workers. Note that the number of running
    workers does not count towards <xref linkend="guc-max-connections"> or
    <xref linkend="guc-superuser-reserved-connections"> limits.
   </para>

   <para>
    Tables whose <structfield>relfrozenxid</> value is more than
    <xref linkend="guc-autovacuum-freeze-max-age"> transactions old are always
    vacuumed (this also applies to those tables whose freeze max age has
    been modified via storage parameters; see below).  Otherwise, if the
    number of tuples obsoleted since the last
    <command>VACUUM</command> exceeds the <quote>vacuum threshold</quote>, the
    table is vacuumed.  The vacuum threshold is defined as:
<programlisting>
vacuum threshold = vacuum base threshold + vacuum scale factor * number of tuples
</programlisting>
    where the vacuum base threshold is
    <xref linkend="guc-autovacuum-vacuum-threshold">,
    the vacuum scale factor is
    <xref linkend="guc-autovacuum-vacuum-scale-factor">,
    and the number of tuples is
    <structname>pg_class</structname>.<structfield>reltuples</structfield>.
    The number of obsolete tuples is obtained from the statistics
    collector; it is a semi-accurate count updated by each
    <command>UPDATE</command> and <command>DELETE</command> operation.  (It
    is only semi-accurate because some information might be lost under heavy
    load.)  If the <structfield>relfrozenxid</> value of the table is more
    than <varname>vacuum_freeze_table_age</> transactions old, the whole
    table is scanned to freeze old tuples and advance
    <structfield>relfrozenxid</>, otherwise only pages that have been modified
    since the last vacuum are scanned.
   </para>

   <para>
    For analyze, a similar condition is used: the threshold, defined as:
<programlisting>
analyze threshold = analyze base threshold + analyze scale factor * number of tuples
</programlisting>
    is compared to the total number of tuples inserted, updated, or deleted
    since the last <command>ANALYZE</command>.
   </para>

   <para>
    Temporary tables cannot be accessed by autovacuum.  Therefore,
    appropriate vacuum and analyze operations should be performed via
    session SQL commands.
   </para>

   <para>
    The default thresholds and scale factors are taken from
    <filename>postgresql.conf</filename>, but it is possible to override them
    on a table-by-table basis; see
    <xref linkend="sql-createtable-storage-parameters"
    endterm="sql-createtable-storage-parameters-title"> for more information.
    If a setting
    has been changed via storage parameters, that value is used; otherwise the
    global settings are used. See <xref linkend="runtime-config-autovacuum"> for
    more details on the global settings.
   </para>

   <para>
    Besides the base threshold values and scale factors, there are six
    more autovacuum parameters that can be set for each table via
    storage parameters.
    The first parameter, <literal>autovacuum_enabled</>,
    can be set to <literal>false</literal> to instruct the autovacuum daemon
    to skip that particular table entirely.  In this case
    autovacuum will only touch the table if it must do so
    to prevent transaction ID wraparound.
    Another two parameters,
    <varname>autovacuum_vacuum_cost_delay</> and
    <varname>autovacuum_vacuum_cost_limit</>, are used to set
    table-specific values for the cost-based vacuum delay feature
    (see <xref linkend="runtime-config-resource-vacuum-cost">).
    <varname>autovacuum_freeze_min_age</>,
    <varname>autovacuum_freeze_max_age</> and
    <varname>autovacuum_freeze_table_age</> are used to set
    values for <xref linkend="guc-vacuum-freeze-min-age">,
    <xref linkend="guc-autovacuum-freeze-max-age"> and
    <xref linkend="guc-vacuum-freeze-table-age"> respectively.
   </para>

   <para>
    When multiple workers are running, the cost limit is
    <quote>balanced</quote> among all the running workers, so that the
    total impact on the system is the same, regardless of the number
    of workers actually running.
   </para>
  </sect2>
 </sect1>


 <sect1 id="routine-reindex">
  <title>정기적인 인덱스 다시 만들기</title>

  <indexterm zone="routine-reindex">
   <primary>reindex</primary>
  </indexterm>

  <para>
   In some situations it is worthwhile to rebuild indexes periodically
   with the <xref linkend="sql-reindex"> command or a series of individual
   rebuilding steps.

  </para>

  <para>
   B-tree index pages that have become completely empty are reclaimed for
   re-use.  However, there is still a possibility
   of inefficient use of space: if all but a few index keys on a page have
   been deleted, the page remains allocated.  Therefore, a usage
   pattern in which most, but not all, keys in each range are eventually
   deleted will see poor use of space.  For such usage patterns,
   periodic reindexing is recommended.
  </para>

  <para>
   The potential for bloat in non-B-tree indexes has not been well
   researched.  It is a good idea to periodically monitor the index's physical
   size when using any non-B-tree index type.
  </para>

  <para>
   Also, for B-tree indexes, a freshly-constructed index is slightly faster to
   access than one that has been updated many times because logically
   adjacent pages are usually also physically adjacent in a newly built index.
   (This consideration does not apply to non-B-tree indexes.)  It
   might be worthwhile to reindex periodically just to improve access speed.
  </para>

  <para>
   <xref linkend="sql-reindex"> can be used safely and easily in all cases.
   But since the command requires an exclusive table lock, it is
   often preferable to execute an index rebuild with a sequence of
   creation and replacement steps.  Index types that support
   <xref linkend="sql-createindex"> with the <literal>CONCURRENTLY</>
   option can instead be recreated that way. If that is successful and the
   resulting index is valid, the original index can then be replaced by
   the newly built one using a combination of <xref linkend="sql-alterindex">
   and <xref linkend="sql-dropindex">. When an index is used to enforce
   uniqueness or other constraints, <xref linkend="sql-altertable"> might
   be necessary to swap the existing constraint with one enforced by
   the new index. Review this alternate multi-step rebuild approach
   carefully before using it as there are limitations on which
   indexes can be reindexed this way, and errors must be handled.
  </para>
 </sect1>


 <sect1 id="logfile-maintenance">
  <title>로그 파일 관리</title>

  <indexterm zone="logfile-maintenance">
   <primary>서버 로그</primary>
   <secondary>로그 파일 관리</secondary>
  </indexterm>

  <para>
   It is a good idea to save the database server's log output
   somewhere, rather than just discarding it via <filename>/dev/null</>.
   The log output is invaluable when diagnosing
   problems.  However, the log output tends to be voluminous
   (especially at higher debug levels) so you won't want to save it
   indefinitely.  You need to <emphasis>rotate</> the log files so that
   new log files are started and old ones removed after a reasonable
   period of time.
  </para>

  <para>
   If you simply direct the <systemitem>stderr</> of
   <command>postgres</command> into a
   file, you will have log output, but
   the only way to truncate the log file is to stop and restart
   the server. This might be acceptable if you are using
   <productname>PostgreSQL</productname> in a development environment,
   but few production servers would find this behavior acceptable.
  </para>

  <para>
   A better approach is to send the server's
   <systemitem>stderr</> output to some type of log rotation program.
   There is a built-in log rotation facility, which you can use by
   setting the configuration parameter <varname>logging_collector</> to
   <literal>true</> in <filename>postgresql.conf</>.  The control
   parameters for this program are described in <xref
   linkend="runtime-config-logging-where">. You can also use this approach
   to capture the log data in machine readable <acronym>CSV</>
   (comma-separated values) format.
  </para>

  <para>
   Alternatively, you might prefer to use an external log rotation
   program if you have one that you are already using with other
   server software. For example, the <application>rotatelogs</application>
   tool included in the <productname>Apache</productname> distribution
   can be used with <productname>PostgreSQL</productname>.  To do this,
   just pipe the server's
   <systemitem>stderr</> output to the desired program.
   If you start the server with
   <command>pg_ctl</>, then <systemitem>stderr</>
   is already redirected to <systemitem>stdout</>, so you just need a
   pipe command, for example:

<programlisting>
pg_ctl start | rotatelogs /var/log/pgsql_log 86400
</programlisting>
  </para>

  <para>
   Another production-grade approach to managing log output is to
   send it to <application>syslog</> and let
   <application>syslog</> deal with file rotation. To do this, set the
   configuration parameter <varname>log_destination</> to <literal>syslog</>
   (to log to <application>syslog</> only) in
   <filename>postgresql.conf</>. Then you can send a <literal>SIGHUP</literal>
   signal to the <application>syslog</> daemon whenever you want to force it
   to start writing a new log file.  If you want to automate log
   rotation, the <application>logrotate</application> program can be
   configured to work with log files from
   <application>syslog</application>.
  </para>

  <para>
   On many systems, however, <application>syslog</> is not very reliable,
   particularly with large log messages; it might truncate or drop messages
   just when you need them the most.  Also, on <productname>Linux</>,
   <application>syslog</> will flush each message to disk, yielding poor
   performance.  (You can use a <quote><literal>-</></> at the start of the file name
   in the <application>syslog</> configuration file to disable syncing.)
  </para>

  <para>
   Note that all the solutions described above take care of starting new
   log files at configurable intervals, but they do not handle deletion
   of old, no-longer-useful log files.  You will probably want to set
   up a batch job to periodically delete old log files.  Another possibility
   is to configure the rotation program so that old log files are overwritten
   cyclically.
  </para>

  <para>
   <ulink url="http://dalibo.github.io/pgbadger/"><productname>pgBadger</productname></ulink>
   is an external project that does sophisticated log file analysis.
   <ulink
   url="http://bucardo.org/wiki/Check_postgres"><productname>check_postgres</productname></ulink>
   provides Nagios alerts when important messages appear in the log
   files, as well as detection of many other extraordinary conditions.
  </para>
 </sect1>
</chapter>
