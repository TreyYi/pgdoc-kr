<!-- doc/src/sgml/monitoring.sgml -->

<chapter id="monitoring">
 <title>데이터베이스 성능 모니터링</title>

 <indexterm zone="monitoring">
  <primary>모니터링</primary>
  <secondary>데이터베이스 서버</secondary>
 </indexterm>

 <indexterm zone="monitoring">
  <primary>database activity</primary>
  <secondary>monitoring</secondary>
 </indexterm>

 <para>
  데이터베이스 관리자가 하는 일 가운데 하나는 
  <quote>이 데이터베이스 서버가 정상적으로 운영 되고 있는지</quote>
  를 지켜 보는 일이다.
  여기서는 이 일에 대한 부분을 다룬다.
 </para>

  <para>
   데이터베이스 운영 상태를 지켜 보거나, 성능을 분석하는 도구들은 
   여러가지가 있다. 
   이 장에서 다루는 대부분의 내용은 <productname>PostgreSQL</productname>
   통계수집기에 대한 것이지만, 
   <command>ps</>, <command>top</>, <command>iostat</>, <command>vmstat</>
   같은 유닉스에서 일반적으로 사용하는 모니터링 프로그램에 대한 
   설명도 함께 한다. 또한 <xref linkend="sql-explain">
   명령어로 살펴보아야 하는 최적화 되지 못한 쿼리들에 대한 해결 방법도 
   잠깐 다룬다. 물론 <command>EXPLAIN</> 명령어에 대한 
   자세한 설명은 <xref linkend="using-explain">에서 다룬다.
  </para>

 <sect1 id="monitoring-ps">
  <title>표준 유닉스 도구들</title>

  <indexterm zone="monitoring-ps">
   <primary>ps</primary>
   <secondary>프로세스 살펴 보기</secondary>
  </indexterm>

  <para>
   대부분의 유닉스 환경에서는 <productname>PostgreSQL</productname>
   서버의 동작 상태를 <command>ps</> 쉘 명령어만으로도 대략적으로
   살펴 볼 수 있다. 왜냐하면 서버는 자신 하고 있는 각각의 
   하위 프로세스들의 명령어 이름들을 동적으로 바꾸어서 운영체제가 
   그것을 볼 수 있도록 하기 때문이다. 그래서 다음과 같은 간단한 
   명령어로 서버 상태를 살펴 볼 수 있다:

<screen>
$ ps auxww | grep ^postgres
postgres  15551  0.0  0.1  57536  7132 pts/0    S    18:02   0:00 postgres -i
postgres  15554  0.0  0.0  57536  1184 ?        Ss   18:02   0:00 postgres: writer process
postgres  15555  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: checkpointer process
postgres  15556  0.0  0.0  57536   916 ?        Ss   18:02   0:00 postgres: wal writer process
postgres  15557  0.0  0.0  58504  2244 ?        Ss   18:02   0:00 postgres: autovacuum launcher process
postgres  15558  0.0  0.0  17512  1068 ?        Ss   18:02   0:00 postgres: stats collector process
postgres  15582  0.0  0.0  58772  3080 ?        Ss   18:04   0:00 postgres: joe runbug 127.0.0.1 idle
postgres  15606  0.0  0.0  58772  3052 ?        Ss   18:07   0:00 postgres: tgl regression [local] SELECT waiting
postgres  15610  0.0  0.0  58772  3056 ?        Ss   18:07   0:00 postgres: tgl regression [local] idle in transaction
</screen>

   (이 명령은 여러 유닉스 제각각이다. 윗 예제는 요즘 사용하는 리눅스 
   시스템에서 사용하는 명령어다. <command>ps</> 명령의 옵션에 대한
   자세한 설명은 사용하고 있는 유닉스 운영체제 설명서를 
   설펴보는 것이 좋다.)
   윗 예제 출력 결과의 첫번째 줄은 데이터베이스 서버의 
   최상위 프로세스이며, 서버를 실행 할 때 사용했던 옵션들도 
   함께 보인다. (PostgreSQL 서버는 쓰레드 방식이 아니라, 
   다중 프로세스 방식으로 운영된다.  다중 프로세스 방식이란, 
   서버 관리자가 서버 실행 명령어를 OS 쉘에서 실행하면, 
   서버 최상위 프로세스 실행되고, 그 프로세스를 필요한 
   여러 프로세스를 실행하는 방식이다.  - 옮긴이)
   다음 다섯 줄은 이 최상위 프로세스가 실행한 서버 운영에 필요한 
   하위 프로세스들이다.  이것을 서버 백그라운드 프로세스라고 한다.
   이 프로세스들은 윗 예제와 꼭 같지는 않다. 
   <quote>autovacuum launcher</> 프로세스는 autovacuum 기능을 
   사용하지 않으면 보이지 않을 것이며, 
   서버 로그를 stderr 쪽으로 보내지 않고 따로 보관하는 
   기능을 사용한다면,  <quote>postgres: logger process</>
   같은 프로세스도 보일 것이다.
   나머지는 클라이언트가 접속해서 서버측에서 만든 
   세션 프로세스들이다.  이 세션 프로세스들은 
   다음과 같은 양식으로 보여준다:

<screen>
postgres: <replaceable>사용자</> <replaceable>데이터베이스</> <replaceable>호스트</> <replaceable>현재작업상태</>
</screen>

  사용자, 데이터베이스, (클라이언트) 호스트 정보는 
  그 프로세스가 종료 될 때까지 항상 같지만, 
  현재작업상태 정보는 그 세션의 작업 상태에 따라 
  바뀐다. 
  현재작업상태에 <literal>idle</>은 
  이 세션이 클라이언트의 명령을 대기하고 있음을 뜻한다.
  <literal>idle in transaction</>으로 표시되는 것은 
  그 세션이 현재, <command>BEGIN</> 명령을 사용해서, 
  트랜잭션 영역 안에 있지만, 클라이언트 측에서 
  아무 작업도 안하고 있는 상태이다.
  <literal>SELECT</>과 같이 명령어 종류를 보여 주는 경우도 있고, 
  그 뒤에, <literal>waiting</>이 붙어 있는 경우도 있다. 
  이 경우는 다른 프로세스가 어떤 작업을 하고 있어, 
  이 세션이 해당 작업을 대기하고 있는 상태를 나타낸다.
  윗 예제를 보면, 15610 프로세스 때문에, 
  15606 프로세스가 작업을 대기하고 있음을 알 수 있다. 
  (윗 예제 화면에서는 다른 세션들이 없기 때문에, 
  15610 프로세스가 잠금 문제를 일으킨 프로세스로 
  파악 할 수 있다.  어떤 잠금을 사용하고 있기에, 
  다른 프로세스가 기다리고 있는지에 대한 자세한 정보는
  <link linkend="view-pg-locks"><structname>pg_locks</structname></link>
  뷰를 통해서 알 수 있다.)
  </para>

  <para>
   <xref linkend="guc-update-process-title"> 환경 설정값을 
   off로 지정했다면, 프로세스 현재작업상태 자리에는
   그 프로세스의 첫 작업에 대한 이름으로 지정되면, 
   그 프로세스가 종료될 때까지 그대로 유지된다.
   몇몇 OS에서는 이 프로세스 이름을 바꾸는 작업이 부하를 유발한다고
   사용하지 않는 경우도 있고, 또 몇몇 OS에서는 
   이 작업에 대해서 전혀 신경 쓰지 않는 경우도 있다.
  </para>

  <tip>
  <para>
  <productname>Solaris</productname>에서는 
  이 부분 처리가 독특하다. 
  먼저 <command>/bin/ps</command> 명령 대신에, 
  <command>/usr/ucb/ps</command> 사용하고, 
  <option>w</option> 옵션을 두 개 지정하고, 
  서버 시작 최상위 프로세스의 이름이 
  각 세션 프로세스의 이름보다 짧게 지정한다면, 
  세션 프로세스들의 이름이 동적으로 바뀌는 것을 살펴볼 수 있다.
  하지만, 이 세가지 조건 중 하나라도 만족하지 않는다면, 
  모든 프로세스 이름은 서버 최상위 프로세스의 이름과 같게 보인다.
  </para>
  </tip>
 </sect1>

 <sect1 id="monitoring-stats">
  <title>통계 수집기</title>

  <indexterm zone="monitoring-stats">
   <primary>통계</primary>
  </indexterm>

  <para>
   <productname>PostgreSQL</productname> <firstterm>통계 수집기
   statistics collector</>는 서버 운영 상태에 대한 정보를 수집하거나
   보고하기 위한 작업을 하는 백그라운드 시스템이다.  현재, 이 수집기는
   테이블이나 인덱스의 디스크 블록 단위 또는 개별 로우 단위의 접근
   회수를 수집할 수 있다.  또한 각 테이블에 저장 되어있는 총 로우 수를
   수집하며, 각 테이블에 대한 vacuum 작업과, analyze 작업에 관한 정보들도
   수집한다. 또한 사용자 정의 함수들의 호출 회수와, 그것들의 각각
   총 수행 시간들도 수집한다.
  </para>

  <para>
   또한 <productname>PostgreSQL</productname>에서는 각각 다른 서버 프로세스들이 자기가 무슨 작업을 하고 있는지에 대한 현재 상태를 살펴볼 수 있다. 이 기능은 수집기 프로세스와 별개로 제공하고 있는 기능이다.
  </para>

 <sect2 id="monitoring-stats-setup">
  <title>통계 수집기 환경설정</title>

  <para>
   통계 자료를 수집한다는 것은 궁극적으로는 그 만큼의 추가 비용을 서버가
   사용한다는 것을 의미한다. 그래서, 그 추가 비용을 얼마만큼 쓸 것인지에
   대한 결정을 서버 환경변수로 제어할 수 있다. 다음은 
   <filename>postgresql.conf</> 환경설정 파일에서 사용할 수 있는
   환경변수들이다. (이들에 대한 보다 자세한 부분은
   <xref linkend="runtime-config">을 참고하라.)
  </para>

  <para>
   <xref linkend="guc-track-activities"> 설정값을 활성화하면 각각의
   서버 프로세스들은 현재 자신이 하고 있는 작업을 프로세스 이름으로 보여준다.
  </para>

  <para>
   <xref linkend="guc-track-counts"> 설정값을 활성화하면 테이블과 인덱스의
   사용빈도를 통계 수집기가 수집한다.
  </para>

  <para>
   <xref linkend="guc-track-functions"> 설정값을 활성화하면 사용자 정의
   함수들의 사용빈도를 통계 수집기가 수집한다.
  </para>

  <para>
   <xref linkend="guc-track-io-timing"> 설정값을 활성화면 블록 읽기
   쓰기 회수를 통계 수집기가 수집한다.
  </para>

  <para>
   일반적으로 이 환경설정 변수들은 <filename>postgresql.conf</>에서
   그 값을 지정하면, 이것은 모든 서버의 프로세스들을 대상으로 작동하게 된다.
   하지만,  <xref linkend="sql-set"> 명령을 이용해서, 개별 세션 단위로
   이 설정값을 변경할 수도 있다. (이 작업은 일반 사용자가 악의적으로
   사용될 가능성이 있기 때문에, 슈퍼유저만 사용할 수 있다.)
  </para>

  <para>
   통계 수집기가 만든 정보는 <xref linkend="guc-stats-temp-directory"> 설정값으로
   지정한 디렉토리 (초기값은 <filename>pg_stat_tmp</filename>) 안에 있는
   임시파일로 저장되고, 그것을 여러 다른 PostgreSQL 프로세스들이 이용한다.
   보다 나은 성능을 위해서는 이 파일의 I/O 성능을 높이기 위해 이 디렉토리를
   메모리 기반 파일시스템에 두는 것도 좋은 방법이다. 이 통계 정보는 서버가
   중지 될 때 <filename>pg_stat</filename> 디렉토리 쪽으로 복사하는
   작업을 하기 때문에, 서버 중지, 재시작에도 자료를 그대로 유지할 수 있다.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-views">
  <title>수집된 통계 정보 보기</title>

  <para>
   수집된 통계 정보는 아래 <xref
   linkend="monitoring-stats-views-table">에서 나열한 여러 뷰를
   통해서 살펴 볼 수 있다. 다른 방법으로는
   <xref linkend="monitoring-stats-functions">에서 제공하는
   여러 통계 정보 보기 함수들을 이용해서 필요한 뷰를 직접 만들어서
   살펴 볼 수도 있을 것이다.
  </para>

  <para>
   여기서 중요한 점은 살펴 보고 있는 통계 정보는 현재 데이터베이스의
   정확한 현재 상태가 아니라는 점이다. 각 개별 프로세스들이 수집한 통계
   정보는 그 프로세스가 아무런 작업을 하고 있지 않을 때, 수집기에게 전달한다.
   즉 한 쿼리가 실행 되고 있다거나 트랜잭션 내에 있다면, 그 과정에
   생긴 통계 정보들은 반영되지 않고 있다는 것이다. 또한 통계 수집기의
   작업은 <varname>PGSTAT_STAT_INTERVAL</varname> (기본값은 500ms 이다)
   시간 간격으로 진행된다. 즉 이 만큼의 통계 정보 오차가 발생한다.
   하지만, <varname>track_activities</varname> 관련 정보는 항상 즉시 반영 된다.
  </para>

  <para>
   또 다른 중요한 점은 한 통계 정보는 해당 뷰나, 함수로 출력할 때,
   한 트랜잭션 내에서는 항상 같은 값을 출력한다. 즉, 트랜젹션이 끝날 때까지
   그 값을 유지한다. 이와 비슷하게 모든 세션들의 현재 쿼리에 대한 정보도
   하나의 트랜잭션 내에서는 같은 정보를 출력한다. 이것은 버그가 아니라
   특성이다. 이것은 한 트랜잭션 내에서 그 통계 정보가 일정하게 유지
   되도록해서 여러 다른 쿼리들에서 그 값을 일관성 있게 한다.  하지만 이것을
   원치 않는다면 각 쿼리들을 트랜잭션 단위로 분리해서 작업하면 된다.  다른
   방법으로 <function>pg_stat_clear_snapshot</function>() 함수를 사용해서,
   현재 스냅숏으로 지정된 통계 정보를 버리고 새 통계 정보를 사용할 수도 있다.
  </para>

  <para>
   하나의 트랜잭션 내에서 그 자신의 통계 정보 (아직까지 수집기 쪽으로 보내지
   않은 현재 작업 내역에 대한 정보)들은 다음과 같은 뷰에서 제공한다:
   <structname>pg_stat_xact_all_tables</>,
   <structname>pg_stat_xact_sys_tables</>,
   <structname>pg_stat_xact_user_tables</>, 
   <structname>pg_stat_xact_user_functions</>.
   이들의 통계 정보는 현재 트랜잭션 내에서도 자신의 세션 작업에 대한 통계치를
   반영 해서 다른 세션에서 수집된 정보와 자신의 세션에서 수집된 정보와 차이가 생길 수도 있다.
  </para>

  <table id="monitoring-stats-views-table">
   <title>표준 통계 정보 뷰</title>

   <tgroup cols="2">
    <thead>
     <row>
      <entry>뷰 이름</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <structname>pg_stat_activity</structname>
       <indexterm><primary>pg_stat_activity</primary></indexterm>
      </entry>
      <entry>
       세션 프로세스들의 정보를 각각 하나의 로우로 보여준다.
       이 프로세스들은 현재 서버를 사용하고는 있는 - 클라이언트가
       서버로 접속 해서 만들어진 하위 서버 프로세스들이며, 이들의
       현재 상태, 실행 중인 쿼리들을 살펴 볼 수 있다.
       자세한 내용은 <xref linkend="pg-stat-activity-view"> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_archiver</><indexterm><primary>pg_stat_archiver</primary></indexterm></entry>
      <entry>WAL 아카이버 프로세스 작동에 대한 
       통계 정보를 하나의 로우로 보여준다.
       자세한 사항은
       <xref linkend="pg-stat-archiver-view"> 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_bgwriter</><indexterm><primary>pg_stat_bgwriter</primary></indexterm></entry>
      <entry>
       백그라운드 라이터 프로세스의 작업 통계 정보.
       자세한 내용은 <xref linkend="pg-stat-bgwriter-view"> 참조. 
     </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database</><indexterm><primary>pg_stat_database</primary></indexterm></entry>
      <entry>한 로우에 하나씩 각 데이터베이스 전역 통계 정보를 보여
       준다. 자세한 내용은 <xref linkend="pg-stat-database-view"> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_tables</><indexterm><primary>pg_stat_all_tables</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블 사용에 대한 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-stat-all-tables-view"> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_tables</><indexterm><primary>pg_stat_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</> 내용과 같은데, 시스템 테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_tables</><indexterm><primary>pg_stat_user_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</> 내용과 같은데, 시스템 테이블을 제외한
      현재 사용자 접근 할 수 있는 테이블에 대한 정보만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_all_tables</><indexterm><primary>pg_stat_xact_all_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_all_tables</> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다.
      (즉 <structname>pg_stat_all_tables</> 쪽으로 반영 되지
      <emphasis>않은</> 트랜잭션 내의 정보다).
      이 뷰에는 사용하는 실 로우 수, 사용하지 않는 로우(dead row) 수,
      vacuum과 analyze 작업에 관계된 정보는 제공하지 않는다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_sys_tables</><indexterm><primary>pg_stat_xact_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_xact_all_tables</> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_tables</><indexterm><primary>pg_stat_xact_user_tables</primary></indexterm></entry>
      <entry><structname>pg_stat_xact_all_tables</> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는 테이블에 대해서만 보여준다.</entry>
     </row>

     <row>
      <entry><structname>pg_stat_all_indexes</><indexterm><primary>pg_stat_all_indexes</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스 사용에 대한 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-stat-all-indexes-view"> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_sys_indexes</><indexterm><primary>pg_stat_sys_indexes</primary></indexterm></entry>
      <entry><structname>pg_stat_all_indexes</> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_indexes</><indexterm><primary>pg_stat_user_indexes</primary></indexterm></entry>
      <entry><structname>pg_stat_all_indexes</> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_tables</><indexterm><primary>pg_statio_all_tables</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 테이블에 대해서
       한 로우씩 그 테이블에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-statio-all-tables-view"> 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_tables</><indexterm><primary>pg_statio_sys_tables</primary></indexterm></entry>
      <entry><structname>pg_statio_all_tables</> 내용과 같은데,
      시스템 테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_tables</><indexterm><primary>pg_statio_user_tables</primary></indexterm></entry>
      <entry><structname>pg_statio_all_tables</> 내용과 같은데,
      시스템 테이블을 제외한 현재 사용자가 접근 할 수 있는
      테이블에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_indexes</><indexterm><primary>pg_statio_all_indexes</primary></indexterm></entry>
      <entry>
       현재 접속한 데이터베이스에 속한 모든 인덱스에 대해서
       한 로우씩 그 인덱스에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-statio-all-indexes-view"> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_indexes</><indexterm><primary>pg_statio_sys_indexes</primary></indexterm></entry>
      <entry><structname>pg_statio_all_indexes</> 내용과 같은데,
      시스템 인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_indexes</><indexterm><primary>pg_statio_user_indexes</primary></indexterm></entry>
      <entry><structname>pg_statio_all_indexes</> 내용과 같은데,
      시스템 인덱스를 제외한 현재 사용자가 접근 할 수 있는
      인덱스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_all_sequences</><indexterm><primary>pg_statio_all_sequences</primary></indexterm></entry>
     <entry>
       현재 접속한 데이터베이스에 속한 모든 시퀀스에 대해서
       한 로우씩 그 시퀀스에 대한 I/O 통계 정보를 보여 준다.
       자세한 내용은 <xref linkend="pg-statio-all-sequences-view"> 참조.
     </entry>
     </row>

     <row>
      <entry><structname>pg_statio_sys_sequences</><indexterm><primary>pg_statio_sys_sequences</primary></indexterm></entry>
      <entry><structname>pg_statio_all_sequences</> 내용과 같은데,
      시스템 시퀀스에 대해서만 보여준다.
      (현재 사용하고 있는 시스템 시퀀스가 없음으로 이 뷰는
      항상 그 내용이 비어있을 것이다.)
      </entry>
     </row>

     <row>
      <entry><structname>pg_statio_user_sequences</><indexterm><primary>pg_statio_user_sequences</primary></indexterm></entry>
      <entry><structname>pg_statio_all_sequences</> 내용과 같은데,
      시스템 시퀀스를 제외한 현재 사용자가 접근 할 수 있는
      시퀀스에 대해서만 보여준다.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_user_functions</><indexterm><primary>pg_stat_user_functions</primary></indexterm></entry>
      <entry>
       현재 데이터베이스에 만들어진 사용자 정의 함수들의
       실행에 대한 통계 정보를 보여준다.
       자세한 내용은 <xref linkend="pg-stat-user-functions-view"> 참조. 
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_xact_user_functions</><indexterm><primary>pg_stat_xact_user_functions</primary></indexterm></entry>
      <entry><structname>pg_stat_user_functions</> 내용과 비슷하지만,
      여기서 반영된 숫자들은 현재 트랜잭션 내에서 반영된 정보만 보여준다,
      (즉 <structname>pg_stat_user_functions</> 쪽으로 반영 되지
      <emphasis>않은</> 트랜잭션 내의 정보다).
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_replication</><indexterm><primary>pg_stat_replication</primary></indexterm></entry>
      <entry>
       하나의 WAL 송신 프로세스에 대해서 하나의 로우로,
       대기 서버 쪽으로 보내는 리플리케이션 작업에 대한 통계 정보를
       보여준다. 자세한 내용은 <xref linkend="pg-stat-replication-view"> 참조.
      </entry>
     </row>

     <row>
      <entry><structname>pg_stat_database_conflicts</><indexterm><primary>pg_stat_database_conflicts</primary></indexterm></entry>
      <entry>
       하나의 데이터베이스에서 그 전역에 걸쳐 발생한 대기 서버
       복제 작업 충돌에 의한 쿼리 실행 실패 통계 정보를 각각 하나의
       로우로 보여준다. 자세한 내용은 <xref linkend="pg-stat-database-conflicts-view"> 참조. 
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   인덱스 별 통계 정보는 어느 인덱스가 많이 사용되며,
   어떻게 영향을 미치는 지를 조사하는데 특히 유용하게 쓰인다.
  </para>

  <para>
   <structname>pg_statio_</> 뷰들은 공유 버퍼의
   사용 빈도를 파악하는데 가장 기본이 되는 것들이다.
   이상적인 서버 운영 모습은 
   디스크 읽기 빈도 보다 공유 버퍼를 사용하는(buffer hit)
   빈도가 훨씬 높아서, 
   대부분의 작업이 커널 호출 작업 없이 이루워 지도록 
   하는 것이다.  한편, <productname>PostgreSQL</>
   에서는 단지 이 서버 기준으로 디스크를 읽은 것과
   서버의 공유 버퍼를 사용한 것에 대한 정보만 제공 할 
   뿐이다.  즉, 커널의 I/O 캐시 사용 빈도에 대해서는 
   제공하지 않는다.  다시 말하면, 
   정말 디스크를 읽은 것인지, OS의 I/O 캐시를 사용한 
   것인지는 이 뷰를 통해서는 알 수 없다.
   이런 세세한 부분까지 살펴 보려면, 
   OS 관련 도구들을 이용해야 할 것이다.
  </para>


  <table id="pg-stat-activity-view" xreflabel="pg_stat_activity">
   <title><structname>pg_stat_activity</structname> View</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of the database this backend is connected to</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the database this backend is connected to</entry>
    </row>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <entry>Process ID of this backend</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of the user logged into this backend</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <entry>Name of the user logged into this backend</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <entry>Name of the application that is connected
      to this backend</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <entry>IP address of the client connected to this backend.
      If this field is null, it indicates either that the client is
      connected via a Unix socket on the server machine or that this is an
      internal process such as autovacuum.
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"> is enabled.
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <entry>TCP port number that the client is using for communication
      with this backend, or <literal>-1</> if a Unix socket is used
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Time when this process was started, i.e., when the
      client connected to the server
     </entry>
    </row>
    <row>
     <entry><structfield>xact_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Time when this process' current transaction was started, or null
      if no transaction is active. If the current
      query is the first of its transaction, this column is equal to the
      <structfield>query_start</> column.
     </entry>
    </row>
    <row>
     <entry><structfield>query_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Time when the currently active query was started, or if
      <structfield>state</> is not <literal>active</>, when the last query
      was started
     </entry>
    </row>
    <row>
     <entry><structfield>state_change</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Time when the <structfield>state</> was last changed</entry>
    </row>
    <row>
     <entry><structfield>waiting</></entry>
     <entry><type>boolean</></entry>
     <entry>True if this backend is currently waiting on a lock</entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry>Current overall state of this backend.
       Possible values are:
       <itemizedlist>
         <listitem>
          <para>
           <literal>active</>: The backend is executing a query.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle</>: The backend is waiting for a new client command.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction</>: The backend is in a transaction,
           but is not currently executing a query.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>idle in transaction (aborted)</>: This state is similar to
           <literal>idle in transaction</>, except one of the statements in
           the transaction caused an error.
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>fastpath function call</>: The backend is executing a
           fast-path function.
          </para>
         </listitem>
         <listitem>
           <para>
           <literal>disabled</>: This state is reported if <xref
           linkend="guc-track-activities"> is disabled in this backend.
          </para>
         </listitem>
       </itemizedlist>
     </entry>
    </row>
    <row>
     <entry><structfield>query</></entry>
     <entry><type>text</></entry>
     <entry>Text of this backend's most recent query. If
      <structfield>state</> is <literal>active</> this field shows the
      currently executing query. In all other states, it shows the last query
      that was executed.
     </entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_activity</structname> view will have one row
   per server process, showing information related to
   the current activity of that process.
  </para>

  <note>
   <para>
    The <structfield>waiting</> and <structfield>state</> columns are
    independent.  If a backend is in the <literal>active</> state,
    it may or may not be <literal>waiting</>.  If the state is
    <literal>active</> and <structfield>waiting</> is true, it means
    that a query is being executed, but is being blocked by a lock
    somewhere in the system.
   </para>
  </note>

  <table id="pg-stat-archiver-view" xreflabel="pg_stat_archiver">
   <title><structname>pg_stat_archiver</structname> View</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>Column</entry>
      <entry>Type</entry>
      <entry>Description</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>archived_count</></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of WAL files that have been successfully archived</entry>
     </row>
     <row>
      <entry><structfield>last_archived_wal</></entry>
      <entry><type>text</type></entry>
      <entry>Name of the last WAL file successfully archived</entry>
     </row>
     <row>
      <entry><structfield>last_archived_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time of the last successful archive operation</entry>
     </row>
     <row>
      <entry><structfield>failed_count</></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of failed attempts for archiving WAL files</entry>
     </row>
     <row>
      <entry><structfield>last_failed_wal</></entry>
      <entry><type>text</type></entry>
      <entry>Name of the WAL file of the last failed archival operation</entry>
     </row>
     <row>
      <entry><structfield>last_failed_time</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time of the last failed archival operation</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time at which these statistics were last reset</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_archiver</structname> view will always have a
   single row, containing data about the archiver process of the cluster.
  </para>

  <table id="pg-stat-bgwriter-view" xreflabel="pg_stat_bgwriter">
   <title><structname>pg_stat_bgwriter</structname> 뷰</title>

   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><structfield>checkpoints_timed</></entry>
      <entry><type>bigint</type></entry>
      <entry>checkpoint_timeout 환경 설정값에 따른 체크 포인트 작업 회수</entry>
     </row>
     <row>
      <entry><structfield>checkpoints_req</></entry>
      <entry><type>bigint</type></entry>
      <entry>체크포인트 명령이 수행되어 진행한 작업 회수</entry>
     </row>
     <row>
      <entry><structfield>checkpoint_write_time</></entry>
      <entry><type>double precision</type></entry>
      <entry>
        체크포인트 작업으로 발생한 디스크 쓰기 작업의 밀리세컨드 총 시간. 
      </entry>
     </row>
     <row>
      <entry><structfield>checkpoint_sync_time</></entry>
      <entry><type>double precision</type></entry>
      <entry>
        체크포인트 작업으로 발생할 디스크 쓰기에
        대한 디스크 동기화 작업(fsync)에 소요된 밀리세컨드 총 시간. 
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_checkpoint</></entry>
      <entry><type>bigint</type></entry>
      <entry>checkpointer 프로세스가 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>buffers_clean</></entry>
      <entry><type>bigint</type></entry>
      <entry>writer 프로세스가 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>maxwritten_clean</></entry>
      <entry><type>bigint</type></entry>
      <entry>writer 프로세스가 기록해야 할 버퍼수가
       bgwriter_lru_maxpages 환경 설정값보다 많아서 작업이 중지된 회수
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_backend</></entry>
      <entry><type>bigint</type></entry>
      <entry>백엔드(세션) 프로세스가 직접 기록한 총 버퍼 수</entry>
     </row>
     <row>
      <entry><structfield>buffers_backend_fsync</></entry>
      <entry><type>bigint</type></entry>
      <entry>백엔드(세션) 프로세스가 직접 <function>fsync</> 작업을
       한 회수 (일반적으로 백엔드(세션) 프로세스가 공유 버퍼를 디스크로
       내려 쓰더라도, 이 동기화 작업은 writer 프로세스가 담당한다.
       즉 writer 프로세스의 fsync 작업 부하량을 파악하는데 도움이 됨 - 옮긴이)
      </entry>
     </row>
     <row>
      <entry><structfield>buffers_alloc</></entry>
      <entry><type>bigint</type></entry>
      <entry>Number of buffers allocated</entry>
     </row>
     <row>
      <entry><structfield>stats_reset</></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>이 통계값들이 초기화 된 시각</entry>
     </row>
    </tbody>
    </tgroup>
  </table>

  <para>
   <structname>pg_stat_bgwriter</structname> 뷰는 항상 한 개의 로우만
   보여준다. 이 자료는 데이터클러스터 전역 정보다.
  </para>

  <table id="pg-stat-database-view" xreflabel="pg_stat_database">
   <title><structname>pg_stat_database</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of a database</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this database</entry>
    </row>
    <row>
     <entry><structfield>numbackends</></entry>
     <entry><type>integer</></entry>
     <entry>Number of backends currently connected to this database.
     This is the only column in this view that returns a value reflecting
     current state; all other columns return the accumulated values since
     the last reset.</entry>
    </row>
    <row>
     <entry><structfield>xact_commit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of transactions in this database that have been
      committed</entry>
    </row>
    <row>
     <entry><structfield>xact_rollback</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of transactions in this database that have been
      rolled back</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read in this database</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of times disk blocks were found already in the buffer
      cache, so that a read was not necessary (this only includes hits in the
      PostgreSQL buffer cache, not the operating system's file system cache)
     </entry>
    </row>
    <row>
     <entry><structfield>tup_returned</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows returned by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_fetched</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows fetched by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_inserted</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows inserted by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_updated</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows updated by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>tup_deleted</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows deleted by queries in this database</entry>
    </row>
    <row>
     <entry><structfield>conflicts</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of queries canceled due to conflicts with recovery
      in this database. (Conflicts occur only on standby servers; see
      <xref linkend="pg-stat-database-conflicts-view"> for details.)
     </entry>
    </row>
    <row>
     <entry><structfield>temp_files</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of temporary files created by queries in this database.
      All temporary files are counted, regardless of why the temporary file
      was created (e.g., sorting or hashing), and regardless of the
      <xref linkend="guc-log-temp-files"> setting.
     </entry>
    </row>
    <row>
     <entry><structfield>temp_bytes</></entry>
     <entry><type>bigint</></entry>
     <entry>Total amount of data written to temporary files by queries in
      this database. All temporary files are counted, regardless of why
      the temporary file was created, and
      regardless of the <xref linkend="guc-log-temp-files"> setting.
     </entry>
    </row>
    <row>
     <entry><structfield>deadlocks</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of deadlocks detected in this database</entry>
    </row>
    <row>
     <entry><structfield>blk_read_time</></entry>
     <entry><type>double precision</></entry>
     <entry>Time spent reading data file blocks by backends in this database,
      in milliseconds</entry>
    </row>
    <row>
     <entry><structfield>blk_write_time</></entry>
     <entry><type>double precision</></entry>
     <entry>Time spent writing data file blocks by backends in this database,
      in milliseconds</entry>
    </row>
    <row>
     <entry><structfield>stats_reset</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Time at which these statistics were last reset</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_database</structname> view will contain one row
   for each database in the cluster, showing database-wide statistics.
  </para>

  <table id="pg-stat-all-tables-view" xreflabel="pg_stat_all_tables">
   <title><structname>pg_stat_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of a table</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the schema that this table is in</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this table</entry>
    </row>
    <row>
     <entry><structfield>seq_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of sequential scans initiated on this table</entry>
    </row>
    <row>
     <entry><structfield>seq_tup_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of live rows fetched by sequential scans</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of index scans initiated on this table</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of live rows fetched by index scans</entry>
    </row>
    <row>
     <entry><structfield>n_tup_ins</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows inserted</entry>
    </row>
    <row>
     <entry><structfield>n_tup_upd</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows updated</entry>
    </row>
    <row>
     <entry><structfield>n_tup_del</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows deleted</entry>
    </row>
    <row>
     <entry><structfield>n_tup_hot_upd</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of rows HOT updated (i.e., with no separate index
      update required)</entry>
    </row>
    <row>
     <entry><structfield>n_live_tup</></entry>
     <entry><type>bigint</></entry>
     <entry>Estimated number of live rows</entry>
    </row>
    <row>
     <entry><structfield>n_dead_tup</></entry>
     <entry><type>bigint</></entry>
     <entry>Estimated number of dead rows</entry>
    </row>
    <row>
     <entry><structfield>last_vacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Last time at which this table was manually vacuumed
      (not counting <command>VACUUM FULL</>)</entry>
    </row>
    <row>
     <entry><structfield>last_autovacuum</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Last time at which this table was vacuumed by the autovacuum
      daemon</entry>
    </row>
    <row>
     <entry><structfield>last_analyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Last time at which this table was manually analyzed</entry>
    </row>
    <row>
     <entry><structfield>last_autoanalyze</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Last time at which this table was analyzed by the autovacuum
      daemon</entry>
    </row>
    <row>
     <entry><structfield>vacuum_count</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of times this table has been manually vacuumed
      (not counting <command>VACUUM FULL</>)</entry>
    </row>
    <row>
     <entry><structfield>autovacuum_count</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of times this table has been vacuumed by the autovacuum
      daemon</entry>
    </row>
    <row>
     <entry><structfield>analyze_count</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of times this table has been manually analyzed</entry>
    </row>
    <row>
     <entry><structfield>autoanalyze_count</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of times this table has been analyzed by the autovacuum
      daemon</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about accesses to that specific table. The
   <structname>pg_stat_user_tables</structname> and
   <structname>pg_stat_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>

  <table id="pg-stat-all-indexes-view" xreflabel="pg_stat_all_indexes">
   <title><structname>pg_stat_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of this index</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the schema this index is in</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this index</entry>
    </row>
    <row>
     <entry><structfield>idx_scan</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of index scans initiated on this index</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of index entries returned by scans on this index</entry>
    </row>
    <row>
     <entry><structfield>idx_tup_fetch</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of live table rows fetched by simple index scans using this
      index</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about accesses to that specific index. The
   <structname>pg_stat_user_indexes</structname> and
   <structname>pg_stat_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>

  <para>
   Indexes can be used via either simple index scans or <quote>bitmap</>
   index scans.  In a bitmap scan
   the output of several indexes can be combined via AND or OR rules,
   so it is difficult to associate individual heap row fetches
   with specific indexes when a bitmap scan is used.  Therefore, a bitmap
   scan increments the
   <structname>pg_stat_all_indexes</>.<structfield>idx_tup_read</>
   count(s) for the index(es) it uses, and it increments the
   <structname>pg_stat_all_tables</>.<structfield>idx_tup_fetch</>
   count for the table, but it does not affect
   <structname>pg_stat_all_indexes</>.<structfield>idx_tup_fetch</>.
  </para>

  <note>
   <para>
    The <structfield>idx_tup_read</> and <structfield>idx_tup_fetch</> counts
    can be different even without any use of bitmap scans,
    because <structfield>idx_tup_read</> counts
    index entries retrieved from the index while <structfield>idx_tup_fetch</>
    counts live rows fetched from the table.  The latter will be less if any
    dead or not-yet-committed rows are fetched using the index, or if any
    heap fetches are avoided by means of an index-only scan.
   </para>
  </note>

  <table id="pg-statio-all-tables-view" xreflabel="pg_statio_all_tables">
   <title><structname>pg_statio_all_tables</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of a table</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the schema that this table is in</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this table</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read from this table</entry>
    </row>
    <row>
     <entry><structfield>heap_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of buffer hits in this table</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read from all indexes on this table</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of buffer hits in all indexes on this table</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read from this table's TOAST table (if any)</entry>
    </row>
    <row>
     <entry><structfield>toast_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of buffer hits in this table's TOAST table (if any)</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read from this table's TOAST table index (if any)</entry>
    </row>
    <row>
     <entry><structfield>tidx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of buffer hits in this table's TOAST table index (if any)</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_statio_all_tables</structname> view will contain
   one row for each table in the current database (including TOAST
   tables), showing statistics about I/O on that specific table. The
   <structname>pg_statio_user_tables</structname> and
   <structname>pg_statio_sys_tables</structname> views
   contain the same information,
   but filtered to only show user and system tables respectively.
  </para>

  <table id="pg-statio-all-indexes-view" xreflabel="pg_statio_all_indexes">
   <title><structname>pg_statio_all_indexes</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of this index</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the schema this index is in</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the table for this index</entry>
    </row>
    <row>
     <entry><structfield>indexrelname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this index</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read from this index</entry>
    </row>
    <row>
     <entry><structfield>idx_blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of buffer hits in this index</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_statio_all_indexes</structname> view will contain
   one row for each index in the current database,
   showing statistics about I/O on that specific index. The
   <structname>pg_statio_user_indexes</structname> and
   <structname>pg_statio_sys_indexes</structname> views
   contain the same information,
   but filtered to only show user and system indexes respectively.
  </para>

  <table id="pg-statio-all-sequences-view" xreflabel="pg_statio_all_sequences">
   <title><structname>pg_statio_all_sequences</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>relid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of a sequence</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the schema this sequence is in</entry>
    </row>
    <row>
     <entry><structfield>relname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this sequence</entry>
    </row>
    <row>
     <entry><structfield>blks_read</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of disk blocks read from this sequence</entry>
    </row>
    <row>
     <entry><structfield>blks_hit</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of buffer hits in this sequence</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_statio_all_sequences</structname> view will contain
   one row for each sequence in the current database,
   showing statistics about I/O on that specific sequence.
  </para>

  <table id="pg-stat-user-functions-view" xreflabel="pg_stat_user_functions">
   <title><structname>pg_stat_user_functions</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>funcid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of a function</entry>
    </row>
    <row>
     <entry><structfield>schemaname</></entry>
     <entry><type>name</></entry>
     <entry>Name of the schema this function is in</entry>
    </row>
    <row>
     <entry><structfield>funcname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this function</entry>
    </row>
    <row>
     <entry><structfield>calls</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of times this function has been called</entry>
    </row>
    <row>
     <entry><structfield>total_time</></entry>
     <entry><type>double precision</></entry>
     <entry>Total time spent in this function and all other functions
     called by it, in milliseconds</entry>
    </row>
    <row>
     <entry><structfield>self_time</></entry>
     <entry><type>double precision</></entry>
     <entry>Total time spent in this function itself, not including
     other functions called by it, in milliseconds</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_user_functions</structname> view will contain
   one row for each tracked function, showing statistics about executions of
   that function.  The <xref linkend="guc-track-functions"> parameter
   controls exactly which functions are tracked.
  </para>

  <table id="pg-stat-replication-view" xreflabel="pg_stat_replication">
   <title><structname>pg_stat_replication</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>pid</></entry>
     <entry><type>integer</></entry>
     <entry>Process ID of a WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>usesysid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of the user logged into this WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>usename</></entry>
     <entry><type>name</></entry>
     <entry>Name of the user logged into this WAL sender process</entry>
    </row>
    <row>
     <entry><structfield>application_name</></entry>
     <entry><type>text</></entry>
     <entry>Name of the application that is connected
      to this WAL sender</entry>
    </row>
    <row>
     <entry><structfield>client_addr</></entry>
     <entry><type>inet</></entry>
     <entry>IP address of the client connected to this WAL sender.
      If this field is null, it indicates that the client is
      connected via a Unix socket on the server machine.
     </entry>
    </row>
    <row>
     <entry><structfield>client_hostname</></entry>
     <entry><type>text</></entry>
     <entry>Host name of the connected client, as reported by a
      reverse DNS lookup of <structfield>client_addr</>. This field will
      only be non-null for IP connections, and only when <xref
      linkend="guc-log-hostname"> is enabled.
     </entry>
    </row>
    <row>
     <entry><structfield>client_port</></entry>
     <entry><type>integer</></entry>
     <entry>TCP port number that the client is using for communication
      with this WAL sender, or <literal>-1</> if a Unix socket is used
     </entry>
    </row>
    <row>
     <entry><structfield>backend_start</></entry>
     <entry><type>timestamp with time zone</></entry>
     <entry>Time when this process was started, i.e., when the
      client connected to this WAL sender
     </entry>
    </row>
    <row>
     <entry><structfield>state</></entry>
     <entry><type>text</></entry>
     <entry>Current WAL sender state</entry>
    </row>
    <row>
     <entry><structfield>sent_location</></entry>
     <entry><type>text</></entry>
     <entry>Last transaction log position sent on this connection</entry>
    </row>
    <row>
     <entry><structfield>write_location</></entry>
     <entry><type>text</></entry>
     <entry>Last transaction log position written to disk by this standby
      server</entry>
    </row>
    <row>
     <entry><structfield>flush_location</></entry>
     <entry><type>text</></entry>
     <entry>Last transaction log position flushed to disk by this standby
      server</entry>
    </row>
    <row>
     <entry><structfield>replay_location</></entry>
     <entry><type>text</></entry>
     <entry>Last transaction log position replayed into the database on this
      standby server</entry>
    </row>
    <row>
     <entry><structfield>sync_priority</></entry>
     <entry><type>integer</></entry>
     <entry>Priority of this standby server for being chosen as the
      synchronous standby</entry>
    </row>
    <row>
     <entry><structfield>sync_state</></entry>
     <entry><type>text</></entry>
     <entry>Synchronous state of this standby server</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_replication</structname> view will contain one row
   per WAL sender process, showing statistics about replication to that
   sender's connected standby server.  Only directly connected standbys are
   listed; no information is available about downstream standby servers.
  </para>

  <table id="pg-stat-database-conflicts-view" xreflabel="pg_stat_database_conflicts">
   <title><structname>pg_stat_database_conflicts</structname> View</title>
   <tgroup cols="3">
    <thead>
    <row>
      <entry>칼럼</entry>
      <entry>자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

   <tbody>
    <row>
     <entry><structfield>datid</></entry>
     <entry><type>oid</></entry>
     <entry>OID of a database</entry>
    </row>
    <row>
     <entry><structfield>datname</></entry>
     <entry><type>name</></entry>
     <entry>Name of this database</entry>
    </row>
    <row>
     <entry><structfield>confl_tablespace</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of queries in this database that have been canceled due to
      dropped tablespaces</entry>
    </row>
    <row>
     <entry><structfield>confl_lock</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of queries in this database that have been canceled due to
      lock timeouts</entry>
    </row>
    <row>
     <entry><structfield>confl_snapshot</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of queries in this database that have been canceled due to
      old snapshots</entry>
    </row>
    <row>
     <entry><structfield>confl_bufferpin</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of queries in this database that have been canceled due to
      pinned buffers</entry>
    </row>
    <row>
     <entry><structfield>confl_deadlock</></entry>
     <entry><type>bigint</></entry>
     <entry>Number of queries in this database that have been canceled due to
      deadlocks</entry>
    </row>
   </tbody>
   </tgroup>
  </table>

  <para>
   The <structname>pg_stat_database_conflicts</structname> view will contain
   one row per database, showing database-wide statistics about
   query cancels occurring due to conflicts with recovery on standby servers.
   This view will only contain information on standby servers, since
   conflicts do not occur on master servers.
  </para>

 </sect2>

 <sect2 id="monitoring-stats-functions">
  <title>통계 함수들</title>

  <para>
   위에서 소개한 뷰를 통해서 서버 통계 정보를 살펴보는 방법과
   함께 또 다른 한 방법은 각각의 정보를 제공하는 
   함수를 사용하는 방법이다.  위에서 
   소개한 뷰들의 뷰 정의를 살펴보면, 
   각각의 뷰가 어떤 함수들을 사용하는지 알 수 있다.
   (예를 들면, <application>psql</> 에서
    <literal>\d+ pg_stat_activity</> 명령을 사용하면 된다.)
   데이터베이스 단위로 통계 정보를 보여주는 
   함수들에 대해서는 함수의 입력 인자로 데이터베이스 OID를 
   입력해야 한다.  이처럼, 테이블별, 인덱스별,
   함수별 통계 정보를 살펴보려면,
   그 각 객체의 OID를 입력 인자로 사용하면 된다.
   기억해야 할 점은, 테이블, 인덱스, 함수 같은 각 데이터베이스
   소속 객체들을 입력 인자로 쓰는 함수라면, 
   그 데이터베이스는 현재 접속한 데이터베이스가 된다.
  </para>

  <para>
   부가적으로 제공하는 통계 관련 함수들은 <xref
   linkend="monitoring-stats-funcs-table">에서 소개한다.
  </para>

  <table id="monitoring-stats-funcs-table">
   <title>부가 통계 함수들</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>함수이름</entry>
      <entry>리턴 자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>

     <row>
       <!-- See also the entry for this in func.sgml -->
      <entry><literal><function>pg_backend_pid()</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Process ID of the server process handling the current session
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_activity</function>(<type>integer</type>)</literal><indexterm><primary>pg_stat_get_activity</primary></indexterm></entry>
      <entry><type>setof record</type></entry>
      <entry>
       Returns a record of information about the backend with the specified PID, or
       one record for each active backend in the system if <symbol>NULL</symbol> is
       specified. The fields returned are a subset of those in the
       <structname>pg_stat_activity</structname> view.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_clear_snapshot()</function></literal><indexterm><primary>pg_stat_clear_snapshot</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Discard the current statistics snapshot
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset()</function></literal><indexterm><primary>pg_stat_reset</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset all statistics counters for the current database to zero
       (requires superuser privileges)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_shared</function>(text)</literal><indexterm><primary>pg_stat_reset_shared</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset some cluster-wide statistics counters to zero, depending on the
       argument (requires superuser privileges).
       Calling <literal>pg_stat_reset_shared('bgwriter')</> will zero all the
       counters shown in the <structname>pg_stat_bgwriter</> view.
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_table_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_table_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset statistics for a single table or index in the current database to
       zero (requires superuser privileges)
      </entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_reset_single_function_counters</function>(oid)</literal><indexterm><primary>pg_stat_reset_single_function_counters</primary></indexterm></entry>
      <entry><type>void</type></entry>
      <entry>
       Reset statistics for a single function in the current database to
       zero (requires superuser privileges)
      </entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <para>
   <structname>pg_stat_activity</> 뷰에서 사용되는
   <function>pg_stat_get_activity</function> 함수는
   지정한 한 세션의 현재 상태에 대한 모든 정보를 
   레코드 자료형으로 리턴한다. 
   이렇게, 가끔은 뷰보다, 함수를 직접 사용하는 것이 
   보다 유용할 때가 있다.  위에서 소개한 뷰들(<xref
   linkend="monitoring-stats-backend-funcs-table">)은 
   함수를 호출하고 그것을 뷰로 보여주기 때문에, 
   뷰를 내용으로 출력 되는 결과는 이미 지난 자료 집합이다
   보다 정확한 현재 상태를 파악 하고자 할 때, 
   이런 함수를 직접 사용하는 방법이 좋다. 
   한 예제를 소개하면,
   다음은, 현재 접속해 있는 세션들의 <acronym>PID</>와
   현재 실행 중인 쿼리 내용을 보는 쿼리다:

<programlisting>
SELECT pg_stat_get_backend_pid(s.backendid) AS pid,
       pg_stat_get_backend_activity(s.backendid) AS query
    FROM (SELECT pg_stat_get_backend_idset() AS backendid) AS s;
</programlisting>
  </para>

  <table id="monitoring-stats-backend-funcs-table">
   <title>백엔드 단위 통계 함수들</title>

   <tgroup cols="3">
    <thead>
     <row>
      <entry>함수이름</entry>
      <entry>리턴 자료형</entry>
      <entry>설명</entry>
     </row>
    </thead>

    <tbody>

     <row>
      <entry><literal><function>pg_stat_get_backend_idset()</function></literal></entry>
      <entry><type>setof integer</type></entry>
      <entry>Set of currently active backend ID numbers (from 1 to the
       number of active backends)</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity(integer)</function></literal></entry>
      <entry><type>text</type></entry>
      <entry>Text of this backend's most recent query</>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_activity_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when the most recent query was started</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_addr(integer)</function></literal></entry>
      <entry><type>inet</type></entry>
      <entry>IP address of the client connected to this backend</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_client_port(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>TCP port number that the client is using for communication</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_dbid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the database this backend is connected to</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_pid(integer)</function></literal></entry>
      <entry><type>integer</type></entry>
      <entry>Process ID of this backend</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when this process was started</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_userid(integer)</function></literal></entry>
      <entry><type>oid</type></entry>
      <entry>OID of the user logged into this backend</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_waiting(integer)</function></literal></entry>
      <entry><type>boolean</type></entry>
      <entry>True if this backend is currently waiting on a lock</entry>
     </row>

     <row>
      <entry><literal><function>pg_stat_get_backend_xact_start(integer)</function></literal></entry>
      <entry><type>timestamp with time zone</type></entry>
      <entry>Time when the current transaction was started</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect2>
 </sect1>

 <sect1 id="monitoring-locks">
  <title>잠금 보기</title>

  <indexterm zone="monitoring-locks">
   <primary>잠금</primary>
   <secondary>모니터링</secondary>
  </indexterm>

  <para>
   데이터베이스 운영 상태를 모니터링 하는 또 다른 도구는
   <structname>pg_locks</structname> 시스템 뷰다.
   이 테이블은 잠금 관리자가 현재 처리하고 있는 
   여러 잠금들에 대한 정보를 제공한다.
   이 테이블로 다음과 같은 정보들을 살펴 볼 수 있다:

   <itemizedlist>
    <listitem>
     <para>
      모든 잠금 상황을 보거나, 
      특정 데이터베이스에 속한 객체들의 잠금을 보거나,
      특정 객체와 관계된 잠금들, 또는 
      <productname>PostgreSQL</productname> 특정
      세션에 관계된 잠금들을 볼 수 있다.
     </para>
    </listitem>

    <listitem>
     <para>
      현재 데이터베이스에서 어떤 세션이 잠금이 필요한데, 
      다른 세션이 먼저 잠그고 있어 다른 세션들이 대기 상태로 있는지를 
      조사할 수 있다.
     </para>
    </listitem>

    <listitem>
     <para>
      잠금 경합 빈도를 살펴 전반적인 서버 성능을 조사할 수 있다.
      또한 이런 경합이 데이터베이스 사용량 변화에 어떤 
      영향을 주는지도 살펴 볼 수 있다.
     </para>
    </listitem>
   </itemizedlist>

   <structname>pg_locks</structname> 뷰에 대한 자세한 설명은
   <xref linkend="view-pg-locks">에서 다룬다.
   또한, 잠금에 대한 설명은 <productname>PostgreSQL</productname>
   동시성 제어에 대한 이해가 선행되어야 쉽게 읽을 수 있다.
   이 부분은 <xref linkend="mvcc">에서 다룬다.
  </para>
 </sect1>

 <sect1 id="dynamic-trace">
  <title>Dynamic Tracing</title>

 <indexterm zone="dynamic-trace">
  <primary>DTrace</primary>
 </indexterm>

  <para>
   <productname>PostgreSQL</productname> provides facilities to support
   dynamic tracing of the database server. This allows an external
   utility to be called at specific points in the code and thereby trace
   execution.
  </para>

  <para>
   A number of probes or trace points are already inserted into the source
   code. These probes are intended to be used by database developers and
   administrators. By default the probes are not compiled into
   <productname>PostgreSQL</productname>; the user needs to explicitly tell
   the configure script to make the probes available.
  </para>

  <para>
   Currently, the
   <ulink url="https://en.wikipedia.org/wiki/DTrace">DTrace</ulink>
   utility is supported, which, at the time of this writing, is available
   on Solaris, Mac OS X, FreeBSD, NetBSD, and Oracle Linux.  The
   <ulink url="http://sourceware.org/systemtap/">SystemTap</ulink> project
   for Linux provides a DTrace equivalent and can also be used.  Supporting other dynamic
   tracing utilities is theoretically possible by changing the definitions for
   the macros in <filename>src/include/utils/probes.h</>.
  </para>

  <sect2 id="compiling-for-trace">
   <title>Compiling for Dynamic Tracing</title>

  <para>
   By default, probes are not available, so you will need to
   explicitly tell the configure script to make the probes available
   in <productname>PostgreSQL</productname>. To include DTrace support
   specify <option>--enable-dtrace</> to configure.  See <xref
   linkend="install-procedure"> for further information.
  </para>
  </sect2>

  <sect2 id="trace-points">
   <title>Built-in Probes</title>

  <para>
   A number of standard probes are provided in the source code,
   as shown in <xref linkend="dtrace-probe-point-table">;
   <xref linkend="typedefs-table">
   shows the types used in the probes.  More probes can certainly be
   added to enhance <productname>PostgreSQL</>'s observability.
  </para>

 <table id="dtrace-probe-point-table">
  <title>Built-in DTrace Probes</title>
  <tgroup cols="3">
   <thead>
    <row>
     <entry>Name</entry>
     <entry>Parameters</entry>
     <entry>설명</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>transaction-start</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Probe that fires at the start of a new transaction.
      arg0 is the transaction ID.</entry>
    </row>
    <row>
     <entry>transaction-commit</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Probe that fires when a transaction completes successfully.
      arg0 is the transaction ID.</entry>
    </row>
    <row>
     <entry>transaction-abort</entry>
     <entry>(LocalTransactionId)</entry>
     <entry>Probe that fires when a transaction completes unsuccessfully.
      arg0 is the transaction ID.</entry>
    </row>
    <row>
     <entry>query-start</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the processing of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-done</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the processing of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-parse-start</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the parsing of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-parse-done</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the parsing of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-rewrite-start</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the rewriting of a query is started.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-rewrite-done</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires when the rewriting of a query is complete.
      arg0 is the query string.</entry>
    </row>
    <row>
     <entry>query-plan-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when the planning of a query is started.</entry>
    </row>
    <row>
     <entry>query-plan-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when the planning of a query is complete.</entry>
    </row>
    <row>
     <entry>query-execute-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when the execution of a query is started.</entry>
    </row>
    <row>
     <entry>query-execute-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when the execution of a query is complete.</entry>
    </row>
    <row>
     <entry>statement-status</entry>
     <entry>(const char *)</entry>
     <entry>Probe that fires anytime the server process updates its
      <structname>pg_stat_activity</>.<structfield>status</>.
      arg0 is the new status string.</entry>
    </row>
    <row>
     <entry>checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>Probe that fires when a checkpoint is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
    <row>
     <entry>checkpoint-done</entry>
     <entry>(int, int, int, int, int)</entry>
     <entry>Probe that fires when a checkpoint is complete.
      (The probes listed next fire in sequence during checkpoint processing.)
      arg0 is the number of buffers written. arg1 is the total number of
      buffers. arg2, arg3 and arg4 contain the number of xlog file(s) added,
      removed and recycled respectively.</entry>
    </row>
    <row>
     <entry>clog-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry>clog-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the CLOG portion of a checkpoint is
      complete. arg0 has the same meaning as for clog-checkpoint-start.</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry>subtrans-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the SUBTRANS portion of a checkpoint is
      complete. arg0 has the same meaning as for
      subtrans-checkpoint-start.</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-start</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      started.
      arg0 is true for normal checkpoint, false for shutdown
      checkpoint.</entry>
    </row>
    <row>
     <entry>multixact-checkpoint-done</entry>
     <entry>(bool)</entry>
     <entry>Probe that fires when the MultiXact portion of a checkpoint is
      complete. arg0 has the same meaning as for
      multixact-checkpoint-start.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-start</entry>
     <entry>(int)</entry>
     <entry>Probe that fires when the buffer-writing portion of a checkpoint
      is started.
      arg0 holds the bitwise flags used to distinguish different checkpoint
      types, such as shutdown, immediate or force.</entry>
    </row>
    <row>
     <entry>buffer-sync-start</entry>
     <entry>(int, int)</entry>
     <entry>Probe that fires when we begin to write dirty buffers during
      checkpoint (after identifying which buffers must be written).
      arg0 is the total number of buffers.
      arg1 is the number that are currently dirty and need to be written.</entry>
    </row>
    <row>
     <entry>buffer-sync-written</entry>
     <entry>(int)</entry>
     <entry>Probe that fires after each buffer is written during checkpoint.
      arg0 is the ID number of the buffer.</entry>
    </row>
    <row>
     <entry>buffer-sync-done</entry>
     <entry>(int, int, int)</entry>
     <entry>Probe that fires when all dirty buffers have been written.
      arg0 is the total number of buffers.
      arg1 is the number of buffers actually written by the checkpoint process.
      arg2 is the number that were expected to be written (arg1 of
      buffer-sync-start); any difference reflects other processes flushing
      buffers during the checkpoint.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-sync-start</entry>
     <entry>()</entry>
     <entry>Probe that fires after dirty buffers have been written to the
      kernel, and before starting to issue fsync requests.</entry>
    </row>
    <row>
     <entry>buffer-checkpoint-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when syncing of buffers to disk is
      complete.</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      started.</entry>
    </row>
    <row>
     <entry>twophase-checkpoint-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when the two-phase portion of a checkpoint is
      complete.</entry>
    </row>
    <row>
     <entry>buffer-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool)</entry>
     <entry>Probe that fires when a buffer read is started.
      arg0 and arg1 contain the fork and block numbers of the page (but
      arg1 will be -1 if this is a relation extension request).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.</entry>
    </row>
    <row>
     <entry>buffer-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, bool, bool)</entry>
     <entry>Probe that fires when a buffer read is complete.
      arg0 and arg1 contain the fork and block numbers of the page (if this
      is a relation extension request, arg1 now contains the block number
      of the newly added block).
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is true for a relation extension request, false for normal
      read.
      arg7 is true if the buffer was found in the pool, false if not.</entry>
    </row>
    <row>
     <entry>buffer-flush-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires before issuing any write request for a shared
      buffer.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry>buffer-flush-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when a write request is complete.  (Note
      that this just reflects the time to pass the data to the kernel;
      it's typically not actually been written to disk yet.)
      The arguments are the same as for buffer-flush-start.</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when a server process begins to write a dirty
      buffer.  (If this happens often, it implies that
      <xref linkend="guc-shared-buffers"> is too
      small or the bgwriter control parameters need adjustment.)
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.</entry>
    </row>
    <row>
     <entry>buffer-write-dirty-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid)</entry>
     <entry>Probe that fires when a dirty-buffer write is complete.
      The arguments are the same as for buffer-write-dirty-start.</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-start</entry>
     <entry>()</entry>
     <entry>Probe that fires when a server process begins to write a
      dirty WAL buffer because no more WAL buffer space is available.
      (If this happens often, it implies that
      <xref linkend="guc-wal-buffers"> is too small.)</entry>
    </row>
    <row>
     <entry>wal-buffer-write-dirty-done</entry>
     <entry>()</entry>
     <entry>Probe that fires when a dirty WAL buffer write is complete.</entry>
    </row>
    <row>
     <entry>xlog-insert</entry>
     <entry>(unsigned char, unsigned char)</entry>
     <entry>Probe that fires when a WAL record is inserted.
      arg0 is the resource manager (rmid) for the record.
      arg1 contains the info flags.</entry>
    </row>
    <row>
     <entry>xlog-switch</entry>
     <entry>()</entry>
     <entry>Probe that fires when a WAL segment switch is requested.</entry>
    </row>
    <row>
     <entry>smgr-md-read-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>Probe that fires when beginning to read a block from a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.</entry>
    </row>
    <row>
     <entry>smgr-md-read-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>Probe that fires when a block read is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is the number of bytes actually read, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
    <row>
     <entry>smgr-md-write-start</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int)</entry>
     <entry>Probe that fires when beginning to write a block to a relation.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.</entry>
    </row>
    <row>
     <entry>smgr-md-write-done</entry>
     <entry>(ForkNumber, BlockNumber, Oid, Oid, Oid, int, int, int)</entry>
     <entry>Probe that fires when a block write is complete.
      arg0 and arg1 contain the fork and block numbers of the page.
      arg2, arg3, and arg4 contain the tablespace, database, and relation OIDs
      identifying the relation.
      arg5 is the ID of the backend which created the temporary relation for a
      local buffer, or InvalidBackendId (-1) for a shared buffer.
      arg6 is the number of bytes actually written, while arg7 is the number
      requested (if these are different it indicates trouble).</entry>
    </row>
    <row>
     <entry>sort-start</entry>
     <entry>(int, bool, int, int, bool)</entry>
     <entry>Probe that fires when a sort operation is started.
      arg0 indicates heap, index or datum sort.
      arg1 is true for unique-value enforcement.
      arg2 is the number of key columns.
      arg3 is the number of kilobytes of work memory allowed.
      arg4 is true if random access to the sort result is required.</entry>
    </row>
    <row>
     <entry>sort-done</entry>
     <entry>(bool, long)</entry>
     <entry>Probe that fires when a sort is complete.
      arg0 is true for external sort, false for internal sort.
      arg1 is the number of disk blocks used for an external sort,
      or kilobytes of memory used for an internal sort.</entry>
    </row>
    <row>
     <entry>lwlock-acquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock has been acquired.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-release</entry>
     <entry>(LWLockId)</entry>
     <entry>Probe that fires when an LWLock has been released (but note
      that any released waiters have not yet been awakened).
      arg0 is the LWLock's ID.</entry>
    </row>
    <row>
     <entry>lwlock-wait-start</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock was not immediately available and
      a server process has begun to wait for the lock to become available.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-wait-done</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when a server process has been released from its
      wait for an LWLock (it does not actually have the lock yet).
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-condacquire</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock was successfully acquired when the
      caller specified no waiting.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lwlock-condacquire-fail</entry>
     <entry>(LWLockId, LWLockMode)</entry>
     <entry>Probe that fires when an LWLock was not successfully acquired when
      the caller specified no waiting.
      arg0 is the LWLock's ID.
      arg1 is the requested lock mode, either exclusive or shared.</entry>
    </row>
    <row>
     <entry>lock-wait-start</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has begun to wait because the lock is not available.
      arg0 through arg3 are the tag fields identifying the object being
      locked.  arg4 indicates the type of object being locked.
      arg5 indicates the lock type being requested.</entry>
    </row>
    <row>
     <entry>lock-wait-done</entry>
     <entry>(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, LOCKMODE)</entry>
     <entry>Probe that fires when a request for a heavyweight lock (lmgr lock)
      has finished waiting (i.e., has acquired the lock).
      The arguments are the same as for lock-wait-start.</entry>
    </row>
    <row>
     <entry>deadlock-found</entry>
     <entry>()</entry>
     <entry>Probe that fires when a deadlock is found by the deadlock
      detector.</entry>
    </row>

   </tbody>
   </tgroup>
  </table>

 <table id="typedefs-table">
  <title>Defined Types Used in Probe Parameters</title>
  <tgroup cols="2">
   <thead>
    <row>
     <entry>자료형</entry>
     <entry>Definition</entry>
    </row>
   </thead>

   <tbody>

    <row>
     <entry>LocalTransactionId</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>LWLockId</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LWLockMode</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>LOCKMODE</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>BlockNumber</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>Oid</entry>
     <entry>unsigned int</entry>
    </row>
    <row>
     <entry>ForkNumber</entry>
     <entry>int</entry>
    </row>
    <row>
     <entry>bool</entry>
     <entry>char</entry>
    </row>

   </tbody>
   </tgroup>
  </table>


  </sect2>

  <sect2 id="using-trace-points">
   <title>Using Probes</title>

  <para>
   The example below shows a DTrace script for analyzing transaction
   counts in the system, as an alternative to snapshotting
   <structname>pg_stat_database</> before and after a performance test:
<programlisting>
#!/usr/sbin/dtrace -qs

postgresql$1:::transaction-start
{
      @start["Start"] = count();
      self->ts  = timestamp;
}

postgresql$1:::transaction-abort
{
      @abort["Abort"] = count();
}

postgresql$1:::transaction-commit
/self->ts/
{
      @commit["Commit"] = count();
      @time["Total time (ns)"] = sum(timestamp - self->ts);
      self->ts=0;
}
</programlisting>
   When executed, the example D script gives output such as:
<screen>
# ./txn_count.d `pgrep -n postgres` or ./txn_count.d &lt;PID&gt;
^C

Start                                          71
Commit                                         70
Total time (ns)                        2312105013
</screen>
  </para>

  <note>
   <para>
    SystemTap uses a different notation for trace scripts than DTrace does,
    even though the underlying trace points are compatible.  One point worth
    noting is that at this writing, SystemTap scripts must reference probe
    names using double underscores in place of hyphens.  This is expected to
    be fixed in future SystemTap releases.
   </para>
  </note>

  <para>
   You should remember that DTrace scripts need to be carefully written and
   debugged, otherwise the trace information collected might
   be meaningless. In most cases where problems are found it is the
   instrumentation that is at fault, not the underlying system. When
   discussing information found using dynamic tracing, be sure to enclose
   the script used to allow that too to be checked and discussed.
  </para>

  <para>
   More example scripts can be found in the PgFoundry
   <ulink url="http://pgfoundry.org/projects/dtrace/">dtrace project</ulink>.
  </para>
  </sect2>

  <sect2 id="defining-trace-points">
   <title>Defining New Probes</title>

  <para>
   New probes can be defined within the code wherever the developer
   desires, though this will require a recompilation. Below are the steps
   for inserting new probes:
  </para>

  <procedure>
   <step>
    <para>
     Decide on probe names and data to be made available through the probes
    </para>
   </step>

   <step>
    <para>
     Add the probe definitions to <filename>src/backend/utils/probes.d</>
    </para>
   </step>

   <step>
    <para>
     Include <filename>pg_trace.h</> if it is not already present in the
     module(s) containing the probe points, and insert
     <literal>TRACE_POSTGRESQL</> probe macros at the desired locations
     in the source code
    </para>
   </step>

   <step>
    <para>
     Recompile and verify that the new probes are available
    </para>
   </step>
  </procedure>

  <formalpara>
   <title>Example:</title>
   <para>
    Here is an example of how you would add a probe to trace all new
    transactions by transaction ID.
   </para>
  </formalpara>

  <procedure>
   <step>
    <para>
     Decide that the probe will be named <literal>transaction-start</> and
     requires a parameter of type LocalTransactionId
    </para>
   </step>

   <step>
    <para>
     Add the probe definition to <filename>src/backend/utils/probes.d</>:
<programlisting>
probe transaction__start(LocalTransactionId);
</programlisting>
     Note the use of the double underline in the probe name. In a DTrace
     script using the probe, the double underline needs to be replaced with a
     hyphen, so <literal>transaction-start</> is the name to document for
     users.
    </para>
   </step>

   <step>
    <para>
     At compile time, <literal>transaction__start</> is converted to a macro
     called <literal>TRACE_POSTGRESQL_TRANSACTION_START</> (notice the
     underscores are single here), which is available by including
     <filename>pg_trace.h</>.  Add the macro call to the appropriate location
     in the source code.  In this case, it looks like the following:

<programlisting>
TRACE_POSTGRESQL_TRANSACTION_START(vxid.localTransactionId);
</programlisting>
    </para>
   </step>

   <step>
    <para>
     After recompiling and running the new binary, check that your newly added
     probe is available by executing the following DTrace command.  You
     should see similar output:
<screen>
# dtrace -ln transaction-start
   ID    PROVIDER          MODULE           FUNCTION NAME
18705 postgresql49878     postgres     StartTransactionCommand transaction-start
18755 postgresql49877     postgres     StartTransactionCommand transaction-start
18805 postgresql49876     postgres     StartTransactionCommand transaction-start
18855 postgresql49875     postgres     StartTransactionCommand transaction-start
18986 postgresql49873     postgres     StartTransactionCommand transaction-start
</screen>
    </para>
   </step>
  </procedure>

  <para>
   There are a few things to be careful about when adding trace macros
   to the C code:

   <itemizedlist>
    <listitem>
     <para>
      You should take care that the data types specified for a probe's
      parameters match the data types of the variables used in the macro.
      Otherwise, you will get compilation errors.
     </para>
    </listitem>


    <listitem>
     <para>
      On most platforms, if <productname>PostgreSQL</productname> is
      built with <option>--enable-dtrace</>, the arguments to a trace
      macro will be evaluated whenever control passes through the
      macro, <emphasis>even if no tracing is being done</>.  This is
      usually not worth worrying about if you are just reporting the
      values of a few local variables.  But beware of putting expensive
      function calls into the arguments.  If you need to do that,
      consider protecting the macro with a check to see if the trace
      is actually enabled:

<programlisting>
if (TRACE_POSTGRESQL_TRANSACTION_START_ENABLED())
    TRACE_POSTGRESQL_TRANSACTION_START(some_function(...));
</programlisting>

      Each trace macro has a corresponding <literal>ENABLED</> macro.
     </para>
    </listitem>
   </itemizedlist>

  </para>

  </sect2>

 </sect1>

</chapter>
