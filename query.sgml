<!-- doc/src/sgml/query.sgml -->

 <chapter id="tutorial-sql">
  <title><acronym>SQL</acronym> 언어</title>

  <sect1 id="tutorial-sql-intro">
   <title>소개</title>

   <para>
    여기서는 데이터베이스에서 사용하는 <acronym>SQL</acronym> 언어에
    대해서 개괄적으로 다룹니다.  이 자습서로는 <acronym>SQL</acronym> 언어에
    대한 모든 것을 설명하기에는 그 지면이 부족할 뿐 아니라, 처음 접하는
    사람들에게 오히려 복잡함만 초래하기에 여기서는 그 대략적인 사용법에
    대해서만 언급합니다. <acronym>SQL</acronym> 언어에 대한 도서로는 <xref
    linkend="MELT93">, <xref linkend="DATE97"> 등이 있습니다.  관심 있으신
    분은 읽어 보시길 바랍니다.  물론
    <productname>PostgreSQL</productname>에서 사용하고 있는 <acronym>SQL</acronym>
    언어는 고유 확장된 부분이 있음을 감안하셔야합니다.
   </para>

   <para>
    이제 실례를 들어 작업하는 것을 살펴보겠습니다. 먼저 앞 장에서 다루웠는
    <literal>mydb</literal> 이름의 데이터베이스가 만들어졌다고 가정하고,
    <application>psql</application> 프로그램을 실행시킬
    수 있다는 가정 아래 이야기를 진행하겠습니다.
   </para>

   <para>
    이 자습서에서 사용되는 예제 자료는 <productname>PostgreSQL</productname> 배포 소스의
    <filename>src/tutorial/</filename> 디렉토리 안에 있습니다.  (바이너리 배포판에는
    이 자습서가 포함되지 않습니다.)  일단
    시작부터 하려면, 해당 디렉토리로 이동해서 <application>make</> 명령을 실행하십시오:

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/src/tutorial</userinput>
<prompt>$</prompt> <userinput>make</userinput>
</screen>

    이 작업은 C 파일을 컴파일 하여, 사용자 정의 함수와 자료형을 만드는 
    동적 라이브러리 파일과 그것을 사용하는 스크립트들을 만듭니다. 다음,
    자습서를 시작하려면 다음과 같이 입력합니다:

<screen>
<prompt>$</prompt> <userinput>cd <replaceable>....</replaceable>/tutorial</userinput>
<prompt>$</prompt> <userinput>psql -s mydb</userinput>
<computeroutput>
...
</computeroutput>

<prompt>mydb=&gt;</prompt> <userinput>\i basics.sql</userinput>
</screen>

    <literal>\i</literal>  명령은 지정한 파일의 내용을
    실행하는 <application>psql</> 내장 명령어입니다.  - 물론 basics.sql
    파일안에는 <productname>PostgreSQL</productname> 서버에서
    실행될 SQL 명령들이 있겠지요.  <application>psql</> 프로그램을
    실행할 때, <literal>-s</literal> 옵션을 사용하면, 이 SQL 명령들을 하나씩 확인하면서
    실행할 수 있습니다.  <filename>basics.sql</filename> 파일안에는 앞으로 이 자습서에서
    사용될 각종 테이블들과 그 자료들을 만드는 명령들이 들어있습니다.

   </para>
  </sect1>


  <sect1 id="tutorial-concepts">
   <title>개념</title>

   <para>
    <indexterm><primary>relational database</primary></indexterm>
    <indexterm><primary>hierarchical database</primary></indexterm>
    <indexterm><primary>object-oriented database</primary></indexterm>
    <indexterm><primary>relation</primary></indexterm>
    <indexterm><primary>table</primary></indexterm>
    <indexterm><primary>관계형 데이터베이스</primary></indexterm>
    <indexterm><primary>계층형 데이터베이스</primary></indexterm>
    <indexterm><primary>객체지향형 데이터베이스</primary></indexterm>
    <indexterm><primary>릴레이션</primary></indexterm>
    <indexterm><primary>테이블</primary></indexterm>

    <productname>PostgreSQL</productname>은 관계형 데이터베이스
    관리 시스템(<acronym>RDBMS</acronym>, <firstterm>relational database management 
    system</firstterm>)입니다.  이 말은 <firstterm>관계들</firstterm>로
    구성된 자료를 관리하기 위한 시스템이라고 풀이하죠.  이
    관계라는 용어는 원래 수학용어였는데, 이것이
    RDBMS에서는 <firstterm>테이블</firstterm> 사이의 수학적 관계를 설명하는데 이용되었고,
    결국 관계형 테이터베이스라는 용어로 사용되었습니다(이
    관계는 수학의 집합이론의 한 부분입니다).  자료를
    테이블로 저장하는 방식은 오늘날 너무도 당연한 것으로 인식되고
    있습니다.  하지만 이것은 단지, 데이터베이스를 구현하는
    여러가지 방법 가운데 하나일 뿐입니다.  유닉스 계열 운영체제에서
    사용되는 파일과 디렉토리 개념은 계층형 데이터베이스를 구현하는
    한 예입니다.  또한 최근에는 객체지향 개념을 이용해서 테이터베이스를 구현합니다.
   </para>

   <para>
    <indexterm><primary>row</primary></indexterm>
    <indexterm><primary>column</primary></indexterm>
    <indexterm><primary>로우</primary></indexterm>
    <indexterm><primary>칼럼</primary></indexterm>

    각각의 테이블은 <firstterm>로우</firstterm> 라고 불리는 것들의 집합입니다.  테이블을
    구성하는 그 각각의 로우는 특정 자료 형태로 표현되는
    각각의 <firstterm>칼럼</firstterm>들의 집합니다.  이
    칼럼들의 순서가 각각의 로우에 일정하게 정해져 있지만,  SQL에서는 테이블의
    칼럼을 다룰 때 그 순서가 뒤섞여도 전혀 상관 없다는 사실을 기억해 두야합니다.  이
    점이 관계형 데이터베이스 개념 가운데 꽤 중요한 개념입니다.
   </para>

   <para>
    <indexterm><primary>database cluster</primary></indexterm>
    <indexterm><primary>데이터베이스 클러스터</primary></indexterm>
    <indexterm><primary>cluster</primary><secondary>of databases</secondary><see>database cluster</see></indexterm>

    테이블들은 데이터베이스 안에 있고, 이 데이터베이스들의 모음을
    하나의 <productname>PostgreSQL</productname> 서버가 관리합니다.  이 하나의
    서버가 관리하는 데이터베이스 집합 단위를 <firstterm>클러스터</firstterm>라 합니다.
   </para>
  </sect1>


  <sect1 id="tutorial-table">
   <title>새 테이블 만들기</title>

   <indexterm zone="tutorial-table">
    <primary>CREATE TABLE</primary>
   </indexterm>

   <para>
    새 테이블은 다음과 같이 테이블의 이름과 그 테이블을 구성하는
    각 칼럼과 그 칼럼의 자료형을 지정해서 만듭니다:

<programlisting>
CREATE TABLE weather (
    city            varchar(80),
    temp_lo         int,           -- low temperature
    temp_hi         int,           -- high temperature
    prcp            real,          -- precipitation
    date            date
);
</programlisting>
    <command>psql</command> 안에서는 하나의 SQL 명령이 
    여러 줄로 나뉘어져 있어도 되고, 한 줄로 모두 표현
    되어도 상관 없습니다.  하지만, 하나의 명령은 반드시
    세미콜론(;)으로 끝나야합니다.
   </para>

   <para>
    SQL 문장을 작성할 때 공백문자(스페이스, 탭, 줄바꿈문자)들은
    자유롭게 사용할 수 있습니다.  즉, 굳이 꼭 위와 같이 그대로
    입력하지 않아도 됩니다.  한 줄로 길게 늘여 써도 상관
    없습니다.  단지 주의할 것은 <quote><literal>--</literal></quote>
    문자는 주석을 표현하는 것인데, 이것이 있으면, 그 다음부터
    줄 끝까지 무시됩니다.  SQL 문법에서는 예약어(keyword, 명령이름,
    구문 중간 중간에 나오는 on, default, not null 같은 것들)와
    식별자(identifier, 테이블 이름, 칼럼 이름  같은 것들)의
    대소문자를 구별하지 않습니다.  단지, 식별자가 큰따옴표(")로
    둘러 쌓여지면, 그 식별자는 입력한 그대로의 대소문자를 유지합니다.
   </para>

   <para>
    <type>varchar(80)</type> 이것은 최대길이가 80글자인
    (주, byte가 아니라, '글자'입니다) 문자열을 저장할 수 있음을
    나타내고, <type>int</type> 이것은 일반적인 정수형 숫자,
    <type>real</type> 이것은 소수점을 사용하는 숫자, <type>date</type>
    이것은 말 그대로 날짜형을 나타냅니다. (윗 명령에서
    처럼 칼럼 이름 <structfield>date</structfield>가 자료형
    이름<type>date</type>와 같을 수도 있습니다.  이런
    방식이 편하기도 하겠지만, 헷갈리기도 할 것입니다.  선택은
    테이블 만드는 사람의 몫입니다.) 
   </para>

   <para>
    <productname>PostgreSQL</productname>에서는
    표준 <acronym>SQL</acronym> 자료형인 <type>int</type>,
    <type>smallint</type>, <type>real</type>, <type>double
    precision</type>, <type>char(<replaceable>N</>)</type>,
    <type>varchar(<replaceable>N</>)</type>, <type>date</type>,
    <type>time</type>, <type>timestamp</type>, 
    <type>interval</type>형을 사용할 수 있으며, 
    또한 일반적인 기타 자료형들과 지리 정보를 담기 위해서
    사용되는 다양한 자료형을 사용할 수 있습니다.
    또한 <productname>PostgreSQL</productname>에서는 
    사용자 정의 자료형을 만들 수 있습니다.  따라서 표준 SQL과의
    호환성을 유지하기 위해서 특별히 문법적으로 예약어 기능을
    해야하는 것들을 제외한 자료형 이름은 문법적인 예약어가
    아닙니다.  (주, 그래서, create table weather (...., data data);
    같은 구문이 가능합니다)
   </para>

   <para>
    다음 예제는 도시 이름과, 그 도시의 위치를 나타내는
    지리정보를 담기위한 테이블을 만드는 것입니다: 
<programlisting>
CREATE TABLE cities (
    name            varchar(80),
    location        point
);
</programlisting>
    <type>point</type> 자료형은 <productname>PostgreSQL</productname>
    고유 자료형입니다. (주, <productname>PostgreSQL</productname> 프로젝트의 시작이
    테이블 상속과 지리정보를 담기 위한 것이였거든요)
   </para>

   <para>
    <indexterm>
     <primary>DROP TABLE</primary>
    </indexterm>

    끝으로, 더 이상 사용하지 않는 테이블을 삭제하거나,
    똑 같은 이름의 테이블을 다른 구조로 다시 만들려면,
    다음과 같은 명령을 사용합니다:
<synopsis>
DROP TABLE <replaceable>테이블이름</replaceable>;
</synopsis>
   </para>
  </sect1>


  <sect1 id="tutorial-populate">
   <title>테이블에 자료 입력하기</title>

   <indexterm zone="tutorial-populate">
    <primary>INSERT</primary>
   </indexterm>

   <para>
    특정 테이블에 자료를 입력할 때는 다음과 같이
    <command>INSERT</command> 구문이 사용됩니다:

<programlisting>
INSERT INTO weather VALUES ('San Francisco', 46, 50, 0.25, '1994-11-27');
</programlisting>

    각 칼럼의 실재 자료들은 그 테이블을 만들 때 지정한
    자료형과 완벽하게 일치해야한다는 것을 명심해야합니다.  특히
    숫자가 아닌 자료일 경우는 윗 예제처럼 작은
    따옴표(<literal>'</>)로 둘러쌓야합니다.  날짜형(<type>date</type>)
    자료를 입력해야할 경우는 그 값이 정확하게
    날짜표현이어야합니다.  (주, <productname>PostgreSQL</productname>에서는 날짜형처리가
    비교적 엄격한 편입니다.  날짜가 아닌 표현에 대해서는 그
    입력 자체가 허용되지 않습니다.  예: 0년 0월 0일, 2003년 2월
    29일같은 것).  날짜형의 입력에 대한 자세한 이야기는
    이 자습서의 범위를 벗어나기에 여기서는 이쯤으로 생략합니다
   </para>

   <para>
    <type>point</type> 자료형은 다음과 같이 하나의 쌍으로
    입력되어야합니다:
<programlisting>
INSERT INTO cities VALUES ('San Francisco', '(-194.0, 53.0)');
</programlisting>
   </para>

   <para>
    한편, 각 칼럼의 입력 순서를 사용자가 다음과 같이
    칼럼명을 미리 원하는 순서대로 지정하고 그 순서에
    맞추어 입력할 수도 있습니다:
<programlisting>
INSERT INTO weather (city, temp_lo, temp_hi, prcp, date)
    VALUES ('San Francisco', 43, 57, 0.0, '1994-11-29');
</programlisting>
    이때는 굳이 테이블을 만들 때의 그 칼럼 순서와 같아야할
    이유도 없으며, 특정 칼럼을 생략하고, 입력할 수도 있습니다.
<programlisting>
INSERT INTO weather (date, city, temp_hi, temp_lo)
    VALUES ('1994-11-29', 'Hayward', 54, 37);
</programlisting>
    많은 개발자들이 처음에 언급한 전체 칼럼을 순서대로
    입력하는 방식보다 지금의 칼럼 이름을 같이 지정해서
    원하는 값만 입력하는 방식을 선호합니다. 
   </para>

   <para>
    이제 윗 방식으로 다음 섹션에서 사용할 데이터를 몇 개
    입력해 보십시오.
   </para>

   <para>
    <indexterm>
     <primary>COPY</primary>
    </indexterm>

    데이터를 입력하는 또 다른 하나의 방법으로
    <command>COPY</command> 명령을 사용하는 방법이 있는데,
    이것은 대용량의 데이터를 빠르게 입력해야할 때 
    사용됩니다.  이 명령은 데이터베이스 백업/복구를 위해서
    <productname>PostgreSQL</productname> 전용으로 특별히
    만들어진 명령입니다.  그래서, 자료를 한꺼번에 입력할 때
    아주 유용하게 사용됩니다.  사용법은 다음과 같습니다:

<programlisting>
COPY weather FROM '/home/user/weather.txt';
</programlisting>

    이때 지정한 파일은 서버가 가동 중인 호스트에
    있어야 합니다. 접속한 서버가 원격호스트 경우라면 윗 파일을 
    원격호스트에서 찾을 것입니다.  <command>COPY</command>
    명령에 대한 자세한 설명은 <xref linkend="sql-copy"> 설명서에
    있습니다.
   </para>
  </sect1>


  <sect1 id="tutorial-select">
   <title>테이블에 있는 자료 조회하기</title>

   <para>
    <indexterm><primary>쿼리</primary></indexterm>
    <indexterm><primary>SELECT</primary></indexterm>

    입력한 자료를 찾아보려면, 테이블을 질의해 보아야 하는데,
    이것을 데이터베이스 용어로 <firstterm>쿼리</firstterm>라고
    합니다. (주, 질의, 쿼리 같은 낯선 용어들이 쓰이지만,
    여기서는 그냥 자료 조회라고 생각하고 넘어가면 됩니다)  이런
    자료 조회를 할 때 사용하는 <acronym>SQL</acronym> 구문이
    <command>SELECT</command> 구문입니다.  이 구문은 크게 세 
    부분으로 구성되는데, 첫번째는 원하는 자료의 칼럼들을
    지정하고, 두번째는 그 칼럼들이 있는 테이블들 - from 절이라고 하고,
    그 다음은 원하는 부분을 지정하는 조건절 - where 절이라고 합니다.  이
    where 절은 선택적으로 사용됩니다.  where 절이 생략되면 지정한
    테이블의 모든 자료를 보여줍니다.  예제로 <structname>weather</structname>
    테이블에 저장된 모든 자료를 보려면 다음과 같이 입력합니다.
<programlisting>
SELECT * FROM weather;
</programlisting>
    여기서  <literal>*</literal> 문자는 <quote>모든 칼럼</quote>을 의미합니다.
     <footnote>
      <para>
       <literal>SELECT *</literal> 구문은 임시로 조회할 때
       유용하게 사용되지, 실재 응용 프로그램 내에서 
       사용할 때는 고려해야할 사항이 많습니다.  왜냐하면, 
       테이블의 칼럼이 있다가 없어지기도 하고, 그 칼럼이 바뀌기도 해서
       원하는 결과가 항상 같을 수 없기 때문입니다.
      </para>
     </footnote>
    그래서, 아래 쿼리와 같은 결과를 보여줍니다:
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date FROM weather;
</programlisting>

    이 쿼리 결과는 다음과 같이 나올 것입니다:

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      43 |      57 |    0 | 1994-11-29
 Hayward       |      37 |      54 |      | 1994-11-29
(3 rows)
</screen>
   </para>

   <para>
    물론 사용자가 직접 입력한 그 내용으로 말입니다.
    그럼 다음 다른 예로:
<programlisting>
SELECT city, (temp_hi+temp_lo)/2 AS temp_avg, date FROM weather;
</programlisting>
    결과는:
<screen>
     city      | temp_avg |    date
---------------+----------+------------
 San Francisco |       48 | 1994-11-27
 San Francisco |       50 | 1994-11-29
 Hayward       |       45 | 1994-11-29
(3 rows)
</screen>
    각 도시의 일평균 기온을 구하는 방법입니다.  여기서
    <literal>AS</literal> 예약어는 생략되어도 되고,
    이것은 그 칼럼의 새로운 이름을 지정할 때 사용합니다.
   </para>

   <para>
    쿼리 문장은 <literal>WHERE</> 절을 사용해서, 
    검색 결과의 조건을 지정할 수 있습니다.  <literal>WHERE</> 절에
    사용할 조건은 불린 조건(참이냐 거짓이냐)
    들의 집합으로 구성됩니다.  일반적으로 불린 조건은 
    불린 연산자(<literal>AND</literal>, <literal>OR</literal>,
    <literal>NOT</literal>)를 이용해서, <literal>WHERE</> 절 전체의
    조건을 구성합니다.  다음 예제는 San Francisco에서 
    비온 날을 찾는 구문입니다:

<programlisting>
SELECT * FROM weather
    WHERE city = 'San Francisco' AND prcp &gt; 0.0;
</programlisting>
    결과는:
<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>ORDER BY</primary></indexterm>

    출력 순서를 바꾸고 싶다면, 다음과 같이
    정렬 조건을 추가합니다:

<programlisting>
SELECT * FROM weather
    ORDER BY city;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 Hayward       |      37 |      54 |      | 1994-11-29
 San Francisco |      43 |      57 |    0 | 1994-11-29
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
</screen>

    이 예제에서 보듯이 위 결과의 정렬은 단지 도시 이름에 대해서만 
    정렬을 하지, 나머지 자료들 기준으로는 정렬하지 않습니다.  각 도시별로
    기온 기준으로 다시 정렬 하려면 다음과 같이 합니다:

<programlisting>
SELECT * FROM weather
    ORDER BY city, temp_lo;
</programlisting>
   </para>

   <para>
    <indexterm><primary>DISTINCT</primary></indexterm>
    <indexterm><primary>duplicate</primary></indexterm>

    같은 값에 대한 중복을 없애려면, 다음과 같이 합니다:

<programlisting>
SELECT DISTINCT city
    FROM weather;
</programlisting>

<screen>
     city
---------------
 Hayward
 San Francisco
(2 rows)
</screen>

    다시, 이 쿼리의 결과에서 도시 이름별 정렬은 되지 않습니다.  그래서
    정렬이 필요하다면, <literal>DISTINCT</literal> 조건과 함께, 
     <literal>ORDER BY</literal> 절도 함께 사용해야 합니다:
     <footnote>
      <para>
       몇 데이터베이스 시스템과, <productname>PostgreSQL</productname>
       오래된 버전에서는 <literal>DISTINCT</literal> 조건을 사용하면
       자동으로 그 칼럼에 대한 <literal>ORDER BY</literal> 조건이 
       적용되어 굳이 <literal>ORDER BY</literal> 절을 사용하지 않아도 되지만,
       최근 <productname>PostgreSQL</productname> 버전에서는 
       <literal>DISTINCT</literal> 조건 만으로는 그 칼럼의 정렬을 
       보장하지 않습니다.
      </para>
     </footnote>

<programlisting>
SELECT DISTINCT city
    FROM weather
    ORDER BY city;
</programlisting>
   </para>
  </sect1>


  <sect1 id="tutorial-join">
   <title>Joins Between Tables</title>

   <indexterm zone="tutorial-join">
    <primary>join</primary>
   </indexterm>

   <para>
    Thus far, our queries have only accessed one table at a time.
    Queries can access multiple tables at once, or access the same
    table in such a way that multiple rows of the table are being
    processed at the same time.  A query that accesses multiple rows
    of the same or different tables at one time is called a
    <firstterm>join</firstterm> query.  As an example, say you wish to
    list all the weather records together with the location of the
    associated city.  To do that, we need to compare the <structfield>city</>
    column of each row of the <structname>weather</> table with the
    <structfield>name</> column of all rows in the <structname>cities</>
    table, and select the pairs of rows where these values match.
    <note>
     <para>
      This  is only a conceptual model.  The join is usually performed
      in a more efficient manner than actually comparing each possible
      pair of rows, but this is invisible to the user.
     </para>
    </note>
    This would be accomplished by the following query:

<programlisting>
SELECT *
    FROM weather, cities
    WHERE city = name;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(2 rows)
</screen>

   </para>

   <para>
    Observe two things about the result set:
    <itemizedlist>
     <listitem>
      <para>
       There is no result row for the city of Hayward.  This is
       because there is no matching entry in the
       <structname>cities</structname> table for Hayward, so the join
       ignores the unmatched rows in the <structname>weather</> table.  We will see
       shortly how this can be fixed.
      </para>
     </listitem>

     <listitem>
      <para>
       There are two columns containing the city name.  This is
       correct because the lists of columns from the
       <structname>weather</structname> and
       <structname>cities</structname> tables are concatenated.  In
       practice this is undesirable, though, so you will probably want
       to list the output columns explicitly rather than using
       <literal>*</literal>:
<programlisting>
SELECT city, temp_lo, temp_hi, prcp, date, location
    FROM weather, cities
    WHERE city = name;
</programlisting>
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <formalpara>
    <title>Exercise:</title>

    <para>
     Attempt to determine the semantics of this query when the
     <literal>WHERE</literal> clause is omitted.
    </para>
   </formalpara>

   <para>
    Since the columns all had different names, the parser
    automatically found which table they belong to.  If there
    were duplicate column names in the two tables you'd need to
    <firstterm>qualify</> the column names to show which one you
    meant, as in:

<programlisting>
SELECT weather.city, weather.temp_lo, weather.temp_hi,
       weather.prcp, weather.date, cities.location
    FROM weather, cities
    WHERE cities.name = weather.city;
</programlisting>

    It is widely considered good style to qualify all column names
    in a join query, so that the query won't fail if a duplicate
    column name is later added to one of the tables.
   </para>

   <para>
    Join queries of the kind seen thus far can also be written in this
    alternative form:

<programlisting>
SELECT *
    FROM weather INNER JOIN cities ON (weather.city = cities.name);
</programlisting>

    This syntax is not as commonly used as the one above, but we show
    it here to help you understand the following topics.
   </para>

   <para>
    <indexterm><primary>join</primary><secondary>outer</secondary></indexterm>

    Now we will figure out how we can get the Hayward records back in.
    What we want the query to do is to scan the
    <structname>weather</structname> table and for each row to find the
    matching <structname>cities</structname> row(s).  If no matching row is
    found we want some <quote>empty values</quote> to be substituted
    for the <structname>cities</structname> table's columns.  This kind
    of query is called an <firstterm>outer join</firstterm>.  (The
    joins we have seen so far are inner joins.)  The command looks
    like this:

<programlisting>
SELECT *
    FROM weather LEFT OUTER JOIN cities ON (weather.city = cities.name);

     city      | temp_lo | temp_hi | prcp |    date    |     name      | location
---------------+---------+---------+------+------------+---------------+-----------
 Hayward       |      37 |      54 |      | 1994-11-29 |               |
 San Francisco |      46 |      50 | 0.25 | 1994-11-27 | San Francisco | (-194,53)
 San Francisco |      43 |      57 |    0 | 1994-11-29 | San Francisco | (-194,53)
(3 rows)
</programlisting>

    This query is called a <firstterm>left outer
    join</firstterm> because the table mentioned on the left of the
    join operator will have each of its rows in the output at least
    once, whereas the table on the right will only have those rows
    output that match some row of the left table.  When outputting a
    left-table row for which there is no right-table match, empty (null)
    values are substituted for the right-table columns.
   </para>

   <formalpara>
    <title>Exercise:</title>

    <para>
     There are also right outer joins and full outer joins.  Try to
     find out what those do.
    </para>
   </formalpara>

   <para>
    <indexterm><primary>join</primary><secondary>self</secondary></indexterm>
    <indexterm><primary>alias</primary><secondary>for table name in query</secondary></indexterm>

    We can also join a table against itself.  This is called a
    <firstterm>self join</firstterm>.  As an example, suppose we wish
    to find all the weather records that are in the temperature range
    of other weather records.  So we need to compare the
    <structfield>temp_lo</> and <structfield>temp_hi</> columns of
    each <structname>weather</structname> row to the
    <structfield>temp_lo</structfield> and
    <structfield>temp_hi</structfield> columns of all other
    <structname>weather</structname> rows.  We can do this with the
    following query:

<programlisting>
SELECT W1.city, W1.temp_lo AS low, W1.temp_hi AS high,
    W2.city, W2.temp_lo AS low, W2.temp_hi AS high
    FROM weather W1, weather W2
    WHERE W1.temp_lo &lt; W2.temp_lo
    AND W1.temp_hi &gt; W2.temp_hi;

     city      | low | high |     city      | low | high
---------------+-----+------+---------------+-----+------
 San Francisco |  43 |   57 | San Francisco |  46 |   50
 Hayward       |  37 |   54 | San Francisco |  46 |   50
(2 rows)
</programlisting>

    Here we have relabeled the weather table as <literal>W1</> and
    <literal>W2</> to be able to distinguish the left and right side
    of the join.  You can also use these kinds of aliases in other
    queries to save some typing, e.g.:
<programlisting>
SELECT *
    FROM weather w, cities c
    WHERE w.city = c.name;
</programlisting>
    You will encounter this style of abbreviating quite frequently.
   </para>
  </sect1>


  <sect1 id="tutorial-agg">
   <title>Aggregate Functions</title>

   <indexterm zone="tutorial-agg">
    <primary>aggregate function</primary>
   </indexterm>

   <para>
    Like  most  other relational database products,
    <productname>PostgreSQL</productname> supports
    <firstterm>aggregate functions</>.
    An aggregate function computes a single result from multiple input rows.
    For example, there are aggregates to compute the
    <function>count</function>, <function>sum</function>,
    <function>avg</function> (average), <function>max</function> (maximum) and
    <function>min</function> (minimum) over a set of rows.
   </para>

   <para>
    As an example, we can find the highest low-temperature reading anywhere
    with:

<programlisting>
SELECT max(temp_lo) FROM weather;
</programlisting>

<screen>
 max
-----
  46
(1 row)
</screen>
   </para>

   <para>
    <indexterm><primary>subquery</primary></indexterm>

    If we wanted to know what city (or cities) that reading occurred in,
    we might try:

<programlisting>
SELECT city FROM weather WHERE temp_lo = max(temp_lo);     <lineannotation>WRONG</lineannotation>
</programlisting>

    but this will not work since the aggregate
    <function>max</function> cannot be used in the
    <literal>WHERE</literal> clause.  (This restriction exists because
    the <literal>WHERE</literal> clause determines which rows will be
    included in the aggregate calculation; so obviously it has to be evaluated
    before aggregate functions are computed.)
    However, as is often the case
    the query can be restated to accomplish the desired result, here
    by using a <firstterm>subquery</firstterm>:

<programlisting>
SELECT city FROM weather
    WHERE temp_lo = (SELECT max(temp_lo) FROM weather);
</programlisting>

<screen>
     city
---------------
 San Francisco
(1 row)
</screen>

    This is OK because the subquery is an independent computation
    that computes its own aggregate separately from what is happening
    in the outer query.
   </para>

   <para>
    <indexterm><primary>GROUP BY</primary></indexterm>
    <indexterm><primary>HAVING</primary></indexterm>

    Aggregates are also very useful in combination with <literal>GROUP
    BY</literal> clauses.  For example, we can get the maximum low
    temperature observed in each city with:

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city;
</programlisting>

<screen>
     city      | max
---------------+-----
 Hayward       |  37
 San Francisco |  46
(2 rows)
</screen>

    which gives us one output row per city.  Each aggregate result is
    computed over the table rows matching that city.
    We can filter these grouped
    rows using <literal>HAVING</literal>:

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>

<screen>
  city   | max
---------+-----
 Hayward |  37
(1 row)
</screen>

    which gives us the same results for only the cities that have all
    <structfield>temp_lo</> values below 40.  Finally, if we only care about
    cities whose
    names begin with <quote><literal>S</literal></quote>, we might do:

<programlisting>
SELECT city, max(temp_lo)
    FROM weather
    WHERE city LIKE 'S%'<co id="co.tutorial-agg-like">
    GROUP BY city
    HAVING max(temp_lo) &lt; 40;
</programlisting>
   <calloutlist>
    <callout arearefs="co.tutorial-agg-like">
     <para>
      The <literal>LIKE</literal> operator does pattern matching and
      is explained in <xref linkend="functions-matching">.
     </para>
    </callout>
   </calloutlist>
   </para>

   <para>
    It is important to understand the interaction between aggregates and
    <acronym>SQL</acronym>'s <literal>WHERE</literal> and <literal>HAVING</literal> clauses.
    The fundamental difference between <literal>WHERE</literal> and
    <literal>HAVING</literal> is this: <literal>WHERE</literal> selects
    input rows before groups and aggregates are computed (thus, it controls
    which rows go into the aggregate computation), whereas
    <literal>HAVING</literal> selects group rows after groups and
    aggregates are computed.  Thus, the
    <literal>WHERE</literal> clause must not contain aggregate functions;
    it makes no sense to try to use an aggregate to determine which rows
    will be inputs to the aggregates.  On the other hand, the
    <literal>HAVING</literal> clause always contains aggregate functions.
    (Strictly speaking, you are allowed to write a <literal>HAVING</literal>
    clause that doesn't use aggregates, but it's seldom useful. The same
    condition could be used more efficiently at the <literal>WHERE</literal>
    stage.)
   </para>

   <para>
    In the previous example, we can apply the city name restriction in
    <literal>WHERE</literal>, since it needs no aggregate.  This is
    more efficient than adding the restriction to <literal>HAVING</literal>,
    because we avoid doing the grouping and aggregate calculations
    for all rows that fail the <literal>WHERE</literal> check.
   </para>
  </sect1>


  <sect1 id="tutorial-update">
   <title>Updates</title>

   <indexterm zone="tutorial-update">
    <primary>UPDATE</primary>
   </indexterm>

   <para>
    You can update existing rows using the
    <command>UPDATE</command> command.
    Suppose you discover the temperature readings are
    all off by 2 degrees after November 28.  You can correct the
    data as follows:

<programlisting>
UPDATE weather
    SET temp_hi = temp_hi - 2,  temp_lo = temp_lo - 2
    WHERE date &gt; '1994-11-28';
</programlisting>
   </para>

   <para>
    Look at the new state of the data:
<programlisting>
SELECT * FROM weather;

     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
 Hayward       |      35 |      52 |      | 1994-11-29
(3 rows)
</programlisting>
   </para>
  </sect1>

  <sect1 id="tutorial-delete">
   <title>Deletions</title>

   <indexterm zone="tutorial-delete">
    <primary>DELETE</primary>
   </indexterm>

   <para>
    Rows can be removed from a table using the <command>DELETE</command>
    command.
    Suppose you are no longer interested in the weather of Hayward.
    Then you can do the following to delete those rows from the table:
<programlisting>
DELETE FROM weather WHERE city = 'Hayward';
</programlisting>

    All weather records belonging to Hayward are removed.

<programlisting>
SELECT * FROM weather;
</programlisting>

<screen>
     city      | temp_lo | temp_hi | prcp |    date
---------------+---------+---------+------+------------
 San Francisco |      46 |      50 | 0.25 | 1994-11-27
 San Francisco |      41 |      55 |    0 | 1994-11-29
(2 rows)
</screen>
   </para>

   <para>
    One should be wary of statements of the form
<synopsis>
DELETE FROM <replaceable>tablename</replaceable>;
</synopsis>

    Without a qualification, <command>DELETE</command> will
    remove  <emphasis>all</>  rows from the given table, leaving it
    empty.  The system will not request confirmation before
    doing this!
   </para>
  </sect1>

 </chapter>
