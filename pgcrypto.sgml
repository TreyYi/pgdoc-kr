<!-- doc/src/sgml/pgcrypto.sgml -->

<sect1 id="pgcrypto" xreflabel="pgcrypto">
 <title>pgcrypto</title>

 <indexterm zone="pgcrypto">
  <primary>pgcrypto</primary>
 </indexterm>

 <indexterm zone="pgcrypto">
  <primary>암호화</primary>
  <secondary>특정 칼럼</secondary>
 </indexterm>

 <para>
  <filename>pgcrypto</> 모듈은 <productname>PostgreSQL</>에서
  사용할 수 있는 암호화 관련 함수를 제공한다.
 </para>

 <sect2>
  <title>일반 해시 함수</title>

  <sect3>
   <title><function>digest()</function></title>

   <indexterm>
    <primary>digest</primary>
   </indexterm>

<synopsis>
digest(data text, type text) returns bytea
digest(data bytea, type text) returns bytea
</synopsis>

   <para>
    입력한 <parameter>data</>의 해시 이진값을 구한다.
    <parameter>type</> 인자는 해시 알고리즘이다.
    표준 알고리즘은 <literal>md5</literal>, <literal>sha1</literal>,
    <literal>sha224</literal>, <literal>sha256</literal>,
    <literal>sha384</literal>, <literal>sha512</literal> 이다.
    <filename>pgcrypto</> 모듈이 OpenSSL 라이브러리를 이용해서
    빌드 되었다면, <xref linkend="pgcrypto-with-without-openssl">에서
    제공하는 것보다 많은 알고리즘을 사용할 수 있다. 
   </para>

   <para>
    함수 반환값의 자료형이 bytea 형이다. 이것을 사용자가
    읽을 수 있는 16진수 문자열로 변환하려면, 
    <function>encode()</> 함수를 사용한다.
    사용 예:
<programlisting>
CREATE OR REPLACE FUNCTION sha1(bytea) returns text AS $$
    SELECT encode(digest($1, 'sha1'), 'hex')
$$ LANGUAGE SQL STRICT IMMUTABLE;
</programlisting>
   </para>
  </sect3>

  <sect3>
   <title><function>hmac()</function></title>

   <indexterm>
    <primary>hmac</primary>
   </indexterm>

<synopsis>
hmac(data text, key text, type text) returns bytea
hmac(data bytea, key text, type text) returns bytea
</synopsis>

   <para>
    입력한 <parameter>data</> 값을 입력한 <parameter>key</> 값으로
    MAC 해시 값을 구한다.
    <parameter>type</> 인자는 <function>digest()</> 함수에서
    사용하는 것과 같다.
   </para>

   <para>
    <function>digest()</> 함수와 같으나, 키 값으로 한 번 더 계산한다.
    이 기능은 누군가가 자료를 변경하고 그에 대응하는 해시 값도 
    바꾸는 문제점을 막는다.
   </para>

   <para>
    키 값이 해시 블록 크기보다 크다면, 먼저 그것의 해시 값을 구한 뒤
    그 값을 키로 사용한다.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>비밀번호 해시 함수</title>

  <para>
   비밀번호 해시 작업은 <function>crypt()</> 함수와
   <function>gen_salt()</> 함수로 구현한다.
   <function>crypt()</> 함수는 해시 작업을 하고, 
   <function>gen_salt()</> 함수는 해시 작업 알고리즘을 
   지정하는데 사용된다.
  </para>

  <para>
   <function>crypt()</> 함수는 보통 MD5나 SHA1 알고리즘을
   이용한 해시 작업과 달리, 다음의 장점이 있다:
  </para>

  <orderedlist>
   <listitem>
    <para>
     이 함수들은 느리다.  입력 값의 크기가 아주 작을 때, 강제로
     비밀번호를 만들 수 있는 유일한 방법이다.
    </para>
   </listitem>
   <listitem>
    <para>
     이 함수들은 <firstterm>salt</>라고 하는 값을 이용해서, 사용자의
     같은 입력값에 대해서 다른 암호화된 비밀번호를 만든다.
     그래서 복호화가 불가능하게 한다.
    </para>
   </listitem>
   <listitem>
    <para>
     이 함수들은 결과 값에 알고리즘 종류를 포함시킨다.  그래서, 
     각기 다른 알고리즘으로 처리된 값이 공존할 수 있다.
    </para>
   </listitem>
   <listitem>
    <para>
     이 함수에서 사용하는 알고리즘 가운데 몇몇은
     적응력이 좋다 &mdash; 이 말은 사용하는 컴퓨터가
     보다 빨라졌을 때, 기존 비밀번호를 모두 초기화 하지 않고, 
     보다 복잡하게 암호화를  할 수 
     있음을 뜻 한다.
    </para>
   </listitem>
  </orderedlist>

  <para>
   <function>crypt()</function> 함수에서 지원하는 알고리즘은
   <xref linkend="pgcrypto-crypt-algorithms">에서 나열하고 있다.
  </para>

  <table id="pgcrypto-crypt-algorithms">
   <title><function>crypt()</> 함수에서 지원하는 알고리즘</title>
   <tgroup cols="6">
    <thead>
     <row>
      <entry>알고리즘</entry>
      <entry>평문 비밀번호 최대 길이</entry>
      <entry>적응력</entry>
      <entry>솔트 비트</entry>
      <entry>출력 길이</entry>
      <entry>설명</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry><literal>bf</></entry>
      <entry>72</entry>
      <entry>있음</entry>
      <entry>128</entry>
      <entry>60</entry>
      <entry>Blowfish 기반, variant 2a</entry>
     </row>
     <row>
      <entry><literal>md5</></entry>
      <entry>제한없음</entry>
      <entry>없음</entry>
      <entry>48</entry>
      <entry>34</entry>
      <entry>MD5 기반 암호화</entry>
     </row>
     <row>
      <entry><literal>xdes</></entry>
      <entry>8</entry>
      <entry>있음</entry>
      <entry>24</entry>
      <entry>20</entry>
      <entry>확장 DES</entry>
     </row>
     <row>
      <entry><literal>des</></entry>
      <entry>8</entry>
      <entry>없음</entry>
      <entry>12</entry>
      <entry>13</entry>
      <entry>전통적인 UNIX crypt</entry>
     </row>
    </tbody>
   </tgroup>
  </table>

  <sect3>
   <title><function>crypt()</></title>

   <indexterm>
    <primary>crypt</primary>
   </indexterm>

<synopsis>
crypt(password text, salt text) returns text
</synopsis>

   <para>
    입력한 <parameter>password</> 문자열에 대한
    crypt(3) 형태의 해시 값을 계산하는 함수.
    첫 비밀번호를 만들 때는 <function>gen_salt()</>
    함수를 이용해 새로운 <parameter>salt</> 값을 만들어 사용하면
    편하다.
    사용자가 입력한 비밀번호가 올바른지를 확인하는 방법은
    저장된 값에서 <parameter>salt</> 값을 구해서, 그 값으로 
    같은 함수의 인자로 사용하고, 그 반환 값이 저장된 값과 같은가를 
    확인한다.
   </para>
   <para>
    새 비밀번호 지정하는 예제:
<programlisting>
UPDATE ... SET pswhash = crypt('new password', gen_salt('md5'));
</programlisting>
   </para>
   <para>
    인증 예제:
<programlisting>
SELECT (pswhash = crypt('entered password', pswhash)) AS pswmatch FROM ... ;
</programlisting>
    이 쿼리의 결과가 <literal>true</>면 입력한 비밀번호가 맞다.
   </para>
  </sect3>

  <sect3>
   <title><function>gen_salt()</></title>

  <indexterm>
   <primary>gen_salt</primary>
  </indexterm>

<synopsis>
gen_salt(type text [, iter_count integer ]) returns text
</synopsis>

   <para>
    <function>crypt()</> 함수에서 사용할 임의의 소금(salt) 문자열을 만든다.
    <function>crypt()</> 함수는 이 문자열을 보고 사용할 알고리즘을 정한다.
   </para>

   <para>
    <parameter>type</> 인자 값은 해시 알고리즘이다.
    사용할 수 있는 알고리즘: <literal>des</literal>, <literal>xdes</literal>,
    <literal>md5</literal>, <literal>bf</literal>.
   </para>

   <para>
    <parameter>iter_count</> 인자 값으로 지정한 알고리즘에서 그 처리 반복 횟수를 
    사용자가 지정할 수 있다.
    이 값이 커지면, 비밀번호 해시 작업에 시간이 더 걸린다.  즉, 암호를 깨는데도
    시간이 더 걸린다.  
    이론상으로는 이 값이 크면 해시 작업을 하는데 시간이 몇 년이 걸릴 수도
    있다 &mdash; 실무에서 쓰지는 않겠지만.  <parameter>iter_count</>
    값을 지정하지 않으면, 그 기본값이 사용된다.
    <parameter>iter_count</> 값으로 허용되는 값은 사용하는 
    알고리즘에 따라 다르며, 구체적인 값은 아래
    <xref linkend="pgcrypto-icfc-table">에 있다.
   </para>

   <table id="pgcrypto-icfc-table">
    <title><function>crypt() 반복 횟수</></title>
    <tgroup cols="4">
     <thead>
      <row>
       <entry>알고리즘</entry>
       <entry>기본값</entry>
       <entry>최소</entry>
       <entry>최대</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>xdes</></entry>
       <entry>725</entry>
       <entry>1</entry>
       <entry>16777215</entry>
      </row>
      <row>
       <entry><literal>bf</></entry>
       <entry>6</entry>
       <entry>4</entry>
       <entry>31</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    <literal>xdes</literal> 알고리즘에서는 이 값이 반드시 홀수값이어야 한다.
   </para>

   <para>
    적당한 반복 횟수를 지정하려면, 전통적으로 사용했던 DES 알고리즘은
    crypt 작업에서
    그 당시 하드웨어로 초당 4회 해시 작업을 할 수 있도록
    설계되었음을 알아야 한다.
    즉, 요즘의 하드웨어 장비로 초당 4회 정도의 해시 작업을 할 수 있으면 
    초기 설계 정신과 맞다는 것이다.  초당 100회 해시 작업을 한다면, 
    너무 빠르다. (해시 작업 반복 회수를 늘리는 것이 좋다.)
   </para>

   <para>
    여러 해시 알고리즘의 상대적 속도 비교는
    <xref linkend="pgcrypto-hash-speed-table">에서 소개하고 있다.
    평문 비밀번호가 8글자인 경우(소문자만으로 구성된 경우,
    숫자, 대문자가 포함된 경우)  모든 조합을 만드는데 걸리는 시간을
    소개하고 있다.
    <literal>crypt-bf</literal> 에서는 그 뒤에 
    <parameter>iter_count</parameter> 값을 지정해서 
    <function>gen_salt</function> 만든 솔트를 쓴 경우를 각각 구분했다.
   </para>

   <table id="pgcrypto-hash-speed-table">
    <title>해시 알고리즘 속도</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>알고리즘</entry>
       <entry>해시/초</entry>
       <entry><literal>[a-z]</> 문자열</entry>
       <entry><literal>[A-Za-z0-9]</> 문자열</entry>
       <entry><literal>md5 해시</>와 비교한 속도</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry><literal>crypt-bf/8</></entry>
       <entry>1792</entry>
       <entry>4 년</entry>
       <entry>3927 년</entry>
       <entry>10만배</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/7</></entry>
       <entry>3648</entry>
       <entry>2 년</entry>
       <entry>1929 년</entry>
       <entry>5만배</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/6</></entry>
       <entry>7168</entry>
       <entry>1 년</entry>
       <entry>982 년</entry>
       <entry>2만5천배</entry>
      </row>
      <row>
       <entry><literal>crypt-bf/5</></entry>
       <entry>13504</entry>
       <entry>188 일</entry>
       <entry>521 년</entry>
       <entry>12,500배</entry>
      </row>
      <row>
       <entry><literal>crypt-md5</></entry>
       <entry>171584</entry>
       <entry>15 일</entry>
       <entry>41 년</entry>
       <entry>1,000배</entry>
      </row>
      <row>
       <entry><literal>crypt-des</></entry>
       <entry>23221568</entry>
       <entry>157.5 분</entry>
       <entry>108 일</entry>
       <entry>7 배</entry>
      </row>
      <row>
       <entry><literal>sha1</></entry>
       <entry>37774272</entry>
       <entry>90 분</entry>
       <entry>68 일</entry>
       <entry>4배</entry>
      </row>
      <row>
       <entry><literal>md5</> (hash)</entry>
       <entry>150085504</entry>
       <entry>22.5 분</entry>
       <entry>17 일</entry>
       <entry>1</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    참고 사항:
   </para>

   <itemizedlist>
    <listitem>
     <para>
     CPU는 Intel Mobile Core i3.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>crypt-des</>와 <literal>crypt-md5</> 알고리즘에 대한 수치는
      John the Ripper v1.6.38 <literal>-test</> 결과를 수집함.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>md5 hash</> 수치는 mdcrack 1.2 결과를 수집함.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>sha1</> 수치는 lcrack-20031130-beta 결과를 수집함.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>crypt-bf</literal> 수치는 반복 횟수를 달리 지정할 수
      있도록 1000개의 8문자 임의 비밀번호를
      반복하는 프로그램을 만들어서 수집함.
      참고: <literal>john
      -test</literal> 에서는 <literal>crypt-bf/5</> 설정에서
      초당 213번 반복했다.
      (<filename>pgcrypto</> 모듈에서 구현한 <literal>crypt-bf</literal>
      해시 기능은 John the Ripper에서 사용한 것과 그 결과의 차이가 미미했다.)
     </para>
    </listitem>
   </itemizedlist>

   <para>
    <quote>모든 조합에 대한 해시 기간</quote>은 실재로 실험해 본 기간이 아니다.
    비밀번호를 알아내는 일반적인 방법은 사전에 있는 단어나,  그 단어와 
    유사하게 생긴 문자열을 사용해서 해시를 해보고, 그것이 해시된 자료와
    같은가를 확인하는 방식으로 진행된다.
    그래서, 일반 단어와 비슷한 비밀번호를 사용한다면, 보다
    알아내기가 쉽다. 그래서, 6개의 문자가 일반 단어와 그 모습이 전혀 다르다면
    비밀번호를 찾아내는 시간이 훨씬 오래 걸린다.
   </para>
  </sect3>
 </sect2>

 <sect2>
  <title>PGP 암호 함수</title>

  <para>
   여기서 소개하는 함수들은 OpenPGP (RFC 4880) 표준에서 암복화 부분을 
   구현한 것이다.
   대칭키와 공개키 암호화를 모두 지원한다.
  </para>

  <para>
   암호화된 PGP 메시지는 두 부분 또는 두 패킷 <firstterm>packets</> 으로 구성된다:
  </para>
  <itemizedlist>
   <listitem>
    <para>
     세션 키를 포함하고 있는 패킷 &mdash; 대칭키나 공개키로 암호화 됨.
    </para>
   </listitem>
   <listitem>
    <para>
     그 세션 키로 암호화 된 자료 패킷.
    </para>
   </listitem>
  </itemizedlist>

  <para>
   대칭키(예, 비밀번호)로 암호화 하는 방법:
  </para>
  <orderedlist>
   <listitem>
    <para>
     지정한 비밀번호는 String2Key (S2K) 알고리즘을 이용해 해시 값으로 바꾼다.
     이 알고리즘은 <function>crypt()</> 알고리즘 &mdash; 
     느리고, 난수 솔트를 사용하는 &mdash; 과 비슷하지만 좀 더 단순하다.
     하지만 이 알고리즘은 비밀번호 전체를 이진 키로 만든다. (crypt() 함수에서
     사용하는 비밀번호의 길이에 대한 것은 윗 부분 참조 - 옮긴이)
    </para>
   </listitem>
   <listitem>
    <para>
     세션 키를 분리하고자 한다면, 새 임의의 키가 생성 된다.
     한편, S2K 형식의 키를 지정하면, 그것을 바로 세션 키로 사용한다.
    </para>
   </listitem>
   <listitem>
    <para>
     S2K 키가 바로 사용되면, S2K 설정만 세션 키 패킷에 포함 된다.
     그 밖의 경우는 S2K 키와 세션 키를 암호화해서
     세션 키 패킷에 포함 된다.
    </para>
   </listitem>
  </orderedlist>

  <para>
   공개키로 암호화 하는 방법:
  </para>
  <orderedlist>
   <listitem>
    <para>
     임의의 세션 키를 만든다.
    </para>
   </listitem>
   <listitem>
    <para>
     그 세션 키를 공개 키로 암호화 해서 세션 키 패킷에 넣는다.
    </para>
   </listitem>
  </orderedlist>

  <para>
   자료 암호화는 다음 작업으로 진행 된다:
  </para>
  <orderedlist>
   <listitem>
    <para>
     선택적 자료 변환 작업: 압축, UTF-8 인코딩으로 변환,
     줄바꿈 문자 변환
    </para>
   </listitem>
   <listitem>
    <para>
     자료에 임의의 바이트가 추가됨.  이것은 임의 IV 값을 
     사용하는 것과 같다.
    </para>
   </listitem>
   <listitem>
    <para>
     임의의 SHA1 해시 값이 자료 앞에 붙고,
    </para>
   </listitem>
   <listitem>
    <para>
     이런 모든 처리가 끝난 다음 세션 키로 암호화 해서 자료 패킷으로 사용한다.
    </para>
   </listitem>
  </orderedlist>

  <sect3>
   <title><function>pgp_sym_encrypt()</function></title>

   <indexterm>
    <primary>pgp_sym_encrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_sym_encrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_sym_encrypt(data text, psw text [, options text ]) returns bytea
pgp_sym_encrypt_bytea(data bytea, psw text [, options text ]) returns bytea
</synopsis>
   <para>
    대칭 PGP 키인 <parameter>psw</> 값으로 <parameter>data</> 값을 암호화 한다.
    <parameter>options</> 값은 아래에서 자세히 설명한다.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_sym_decrypt()</function></title>

   <indexterm>
    <primary>pgp_sym_decrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_sym_decrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_sym_decrypt(msg bytea, psw text [, options text ]) returns text
pgp_sym_decrypt_bytea(msg bytea, psw text [, options text ]) returns bytea
</synopsis>
   <para>
    PGP 메시지(msg)를 지정한 대칭 키(psw)로 복호화 한다.
   </para>
   <para>
    복호화 되는 자료가 이진 자료라면, 
    <function>pgp_sym_decrypt</> 함수로는 복호화 할 수 없다.
    이는 자료에 잘못된 문자있어 출력이 안되는 경우를 피하기 위함이다.
    반대로 복호화 되는 자료가 문자열이다면,
    <function>pgp_sym_decrypt_bytea</> 함수로도 복호화 할 수 있다.
   </para>
   <para>
    <parameter>options</> 값은 아래에서 자세히 설명한다.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_pub_encrypt()</function></title>

   <indexterm>
    <primary>pgp_pub_encrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_pub_encrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_pub_encrypt(data text, key bytea [, options text ]) returns bytea
pgp_pub_encrypt_bytea(data bytea, key bytea [, options text ]) returns bytea
</synopsis>
   <para>
    <parameter>data</> 값을 PGP 공개 키인 <parameter>key</> 값으로 
    암호화 한다.
    이 함수에 비밀 키를 지정하면 오류를 낸다.
   </para>
   <para>
    <parameter>options</> 값은 아래에서 자세히 설명 한다.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_pub_decrypt()</function></title>

   <indexterm>
    <primary>pgp_pub_decrypt</primary>
   </indexterm>

   <indexterm>
    <primary>pgp_pub_decrypt_bytea</primary>
   </indexterm>

<synopsis>
pgp_pub_decrypt(msg bytea, key bytea [, psw text [, options text ]]) returns text
pgp_pub_decrypt_bytea(msg bytea, key bytea [, psw text [, options text ]]) returns bytea
</synopsis>
   <para>
    공개 키로 암호화 된 내용을 복호화 한다.  <parameter>key</> 값은
    암호화 할 때 사용한 공개 키와 쌍이 되는 비밀 키를 사용한다.
    그 비밀 키에 비밀번호를 지정했다면, <parameter>psw</> 인자 값으로
    그 비밀번호를 지정해야 한다.  비밀번호는 없는데, <parameter>options</>
    인자 값을 지정해야 한다면, 비밀번호로 빈 문자열을 지정한다.
   </para>
   <para>
    복호화 되는 자료가 이진 자료라면, 
    <function>pgp_pub_decrypt</> 함수로는 복호화 할 수 없다.
    이는 자료에 잘못된 문자있어 출력이 안되는 경우를 피하기 위함이다.
    반대로 복호화 되는 자료가 문자열이다면,
    <function>pgp_pub_decrypt_bytea</> 함수로도 복호화 할 수 있다.
   </para>
   <para>
    <parameter>options</> 값은 아래에서 자세히 설명 한다.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_key_id()</function></title>

   <indexterm>
    <primary>pgp_key_id</primary>
   </indexterm>

<synopsis>
pgp_key_id(bytea) returns text
</synopsis>
   <para>
    <function>pgp_key_id</> 함수는 PGP 공개 키나 비밀 키에서 키 ID를 추출한다.
    인자가 암호화 된 메시지라면 그 암호화에 사용된 키 ID를 구한다.
   </para>
   <para>
    반환 값으로 두 개의 특수 ID가 있다:
   </para>
   <itemizedlist>
    <listitem>
     <para>
      <literal>SYMKEY</>
     </para>
     <para>
      대칭 키로 암호화 되었음을 뜻한다.
     </para>
    </listitem>
    <listitem>
     <para>
      <literal>ANYKEY</>
     </para>
     <para>
      공개 키로 암호화를 했지만, 키 ID를 빼버린 경우를 뜻한다.
      이 경우라면, 가지고 있는 모든 비밀 키로 풀릴 때까지 
      복호화를 시도해 보아야 한다.
      <filename>pgcrypto</> 모듈을 이용해서 암호화를 하는 경우는
      그 자료를 뽑아서 임의로 키 ID를 빼지 않는 이상 임의로 빼지는 
      않는다.
     </para>
    </listitem>
   </itemizedlist>
   <para>
    전혀 다른 키의 ID가 같은 경우가 있을 수도 있음을 기억해야 한다.
    이 경우는 드문 경우이나, 절대로 일어나지 않는 일은 아니다.
    클라이언트 응용 프로그램에서는 이 경우를 감안 해서, <literal>ANYKEY</>
    ID인 경우에 대한 적당한 작업을 염두해 두어야 한다.
   </para>
  </sect3>

  <sect3>
   <title><function>armor()</function>, <function>dearmor()</function></title>

   <indexterm>
    <primary>armor</primary>
   </indexterm>

   <indexterm>
    <primary>dearmor</primary>
   </indexterm>

<synopsis>
armor(data bytea [ , keys text[], values text[] ]) returns text
dearmor(data text) returns bytea
</synopsis>
   <para>
    These functions wrap/unwrap binary data into PGP ASCII-armor format,
    which is basically Base64 with CRC and additional formatting.
   </para>

   <para>
    If the <parameter>keys</> and <parameter>values</> arrays are specified,
    an <firstterm>armor header</> is added to the armored format for each
    key/value pair. Both arrays must be single-dimensional, and they must
    be of the same length.  The keys and values cannot contain any non-ASCII
    characters.
   </para>
  </sect3>

  <sect3>
   <title><function>pgp_armor_headers</function></title>

   <indexterm>
    <primary>pgp_armor_headers</primary>
   </indexterm>

<synopsis>
pgp_armor_headers(data text, key out text, value out text) returns setof record
</synopsis>
   <para>
    <function>pgp_armor_headers()</> extracts the armor headers from
    <parameter>data</>.  The return value is a set of rows with two columns,
    key and value.  If the keys or values contain any non-ASCII characters,
    they are treated as UTF-8.
   </para>
  </sect3>

  <sect3>
   <title>Options for PGP Functions</title>

   <para>
    Options are named to be similar to GnuPG.  An option's value should be
    given after an equal sign; separate options from each other with commas.
    For example:
<programlisting>
pgp_sym_encrypt(data, psw, 'compress-algo=1, cipher-algo=aes256')
</programlisting>
   </para>

   <para>
    All of the options except <literal>convert-crlf</literal> apply only to
    encrypt functions.  Decrypt functions get the parameters from the PGP
    data.
   </para>

   <para>
    The most interesting options are probably
    <literal>compress-algo</literal> and <literal>unicode-mode</literal>.
    The rest should have reasonable defaults.
   </para>

  <sect4>
   <title>cipher-algo</title>

   <para>
    Which cipher algorithm to use.
   </para>
<literallayout>
Values: bf, aes128, aes192, aes256 (OpenSSL-only: <literal>3des</literal>, <literal>cast5</literal>)
Default: aes128
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>compress-algo</title>

   <para>
    Which compression algorithm to use.  Only available if
    <productname>PostgreSQL</productname> was built with zlib.
   </para>
<literallayout>
Values:
  0 - no compression
  1 - ZIP compression
  2 - ZLIB compression (= ZIP plus meta-data and block CRCs)
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>compress-level</title>

   <para>
    How much to compress.  Higher levels compress smaller but are slower.
    0 disables compression.
   </para>
<literallayout>
Values: 0, 1-9
Default: 6
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>convert-crlf</title>

   <para>
    Whether to convert <literal>\n</literal> into <literal>\r\n</literal> when
    encrypting and <literal>\r\n</literal> to <literal>\n</literal> when
    decrypting.  RFC 4880 specifies that text data should be stored using
    <literal>\r\n</literal> line-feeds.  Use this to get fully RFC-compliant
    behavior.
   </para>
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt, pgp_sym_decrypt, pgp_pub_decrypt
</literallayout>
  </sect4>

  <sect4>
   <title>disable-mdc</title>

   <para>
    Do not protect data with SHA-1.  The only good reason to use this
    option is to achieve compatibility with ancient PGP products, predating
    the addition of SHA-1 protected packets to RFC 4880.
    Recent gnupg.org and pgp.com software supports it fine.
   </para>
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>sess-key</title>

   <para>
    Use separate session key.  Public-key encryption always uses a separate
    session key; this option is for symmetric-key encryption, which by default
    uses the S2K key directly.
   </para>
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>s2k-mode</title>

   <para>
    Which S2K algorithm to use.
   </para>
<literallayout>
Values:
  0 - Without salt.  Dangerous!
  1 - With salt but with fixed iteration count.
  3 - Variable iteration count.
Default: 3
Applies to: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>s2k-digest-algo</title>

   <para>
    Which digest algorithm to use in S2K calculation.
   </para>
<literallayout>
Values: md5, sha1
Default: sha1
Applies to: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>s2k-cipher-algo</title>

   <para>
    Which cipher to use for encrypting separate session key.
   </para>
<literallayout>
Values: bf, aes, aes128, aes192, aes256
Default: use cipher-algo
Applies to: pgp_sym_encrypt
</literallayout>
  </sect4>

  <sect4>
   <title>unicode-mode</title>

   <para>
    Whether to convert textual data from database internal encoding to
    UTF-8 and back.  If your database already is UTF-8, no conversion will
    be done, but the message will be tagged as UTF-8.  Without this option
    it will not be.
   </para>
<literallayout>
Values: 0, 1
Default: 0
Applies to: pgp_sym_encrypt, pgp_pub_encrypt
</literallayout>
  </sect4>
  </sect3>

 <sect3>
  <title>Generating PGP Keys with GnuPG</title>

  <para>
   To generate a new key:
<programlisting>
gpg --gen-key
</programlisting>
  </para>
  <para>
   The preferred key type is <quote>DSA and Elgamal</>.
  </para>
  <para>
   For RSA encryption you must create either DSA or RSA sign-only key
   as master and then add an RSA encryption subkey with
   <literal>gpg --edit-key</literal>.
  </para>
  <para>
   To list keys:
<programlisting>
gpg --list-secret-keys
</programlisting>
  </para>
  <para>
   To export a public key in ASCII-armor format:
<programlisting>
gpg -a --export KEYID > public.key
</programlisting>
  </para>
  <para>
   To export a secret key in ASCII-armor format:
<programlisting>
gpg -a --export-secret-keys KEYID > secret.key
</programlisting>
  </para>
  <para>
   You need to use <function>dearmor()</> on these keys before giving them to
   the PGP functions.  Or if you can handle binary data, you can drop
   <literal>-a</literal> from the command.
  </para>
  <para>
   For more details see <literal>man gpg</literal>,
   <ulink url="http://www.gnupg.org/gph/en/manual.html">The GNU
   Privacy Handbook</ulink> and other documentation on
   <ulink url="http://www.gnupg.org"></ulink>.
  </para>
 </sect3>

 <sect3>
  <title>Limitations of PGP Code</title>

  <itemizedlist>
   <listitem>
    <para>
    No support for signing.  That also means that it is not checked
    whether the encryption subkey belongs to the master key.
    </para>
   </listitem>
   <listitem>
    <para>
    No support for encryption key as master key.  As such practice
    is generally discouraged, this should not be a problem.
    </para>
   </listitem>
   <listitem>
    <para>
    No support for several subkeys.  This may seem like a problem, as this
    is common practice.  On the other hand, you should not use your regular
    GPG/PGP keys with <filename>pgcrypto</>, but create new ones,
    as the usage scenario is rather different.
    </para>
   </listitem>
  </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <title>Raw Encryption Functions</title>

  <para>
   These functions only run a cipher over data; they don't have any advanced
   features of PGP encryption.  Therefore they have some major problems:
  </para>
  <orderedlist>
   <listitem>
    <para>
    They use user key directly as cipher key.
    </para>
   </listitem>
   <listitem>
    <para>
    They don't provide any integrity checking, to see
    if the encrypted data was modified.
    </para>
   </listitem>
   <listitem>
    <para>
    They expect that users manage all encryption parameters
    themselves, even IV.
    </para>
   </listitem>
   <listitem>
    <para>
    They don't handle text.
    </para>
   </listitem>
  </orderedlist>
  <para>
   So, with the introduction of PGP encryption, usage of raw
   encryption functions is discouraged.
  </para>

  <indexterm>
   <primary>encrypt</primary>
  </indexterm>

  <indexterm>
   <primary>decrypt</primary>
  </indexterm>

  <indexterm>
   <primary>encrypt_iv</primary>
  </indexterm>

  <indexterm>
   <primary>decrypt_iv</primary>
  </indexterm>

<synopsis>
encrypt(data bytea, key bytea, type text) returns bytea
decrypt(data bytea, key bytea, type text) returns bytea

encrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
decrypt_iv(data bytea, key bytea, iv bytea, type text) returns bytea
</synopsis>

  <para>
   Encrypt/decrypt data using the cipher method specified by
   <parameter>type</parameter>.  The syntax of the
   <parameter>type</parameter> string is:

<synopsis>
<replaceable>algorithm</> <optional> <literal>-</> <replaceable>mode</> </optional> <optional> <literal>/pad:</> <replaceable>padding</> </optional>
</synopsis>
   where <replaceable>algorithm</> is one of:

  <itemizedlist>
   <listitem><para><literal>bf</literal> &mdash; Blowfish</para></listitem>
   <listitem><para><literal>aes</literal> &mdash; AES (Rijndael-128)</para></listitem>
  </itemizedlist>
   and <replaceable>mode</> is one of:
  <itemizedlist>
   <listitem>
    <para>
    <literal>cbc</literal> &mdash; next block depends on previous (default)
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>ecb</literal> &mdash; each block is encrypted separately (for
    testing only)
    </para>
   </listitem>
  </itemizedlist>
   and <replaceable>padding</> is one of:
  <itemizedlist>
   <listitem>
    <para>
    <literal>pkcs</literal> &mdash; data may be any length (default)
    </para>
   </listitem>
   <listitem>
    <para>
    <literal>none</literal> &mdash; data must be multiple of cipher block size
    </para>
   </listitem>
  </itemizedlist>
  </para>
  <para>
   So, for example, these are equivalent:
<programlisting>
encrypt(data, 'fooz', 'bf')
encrypt(data, 'fooz', 'bf-cbc/pad:pkcs')
</programlisting>
  </para>
  <para>
   In <function>encrypt_iv</> and <function>decrypt_iv</>, the
   <parameter>iv</> parameter is the initial value for the CBC mode;
   it is ignored for ECB.
   It is clipped or padded with zeroes if not exactly block size.
   It defaults to all zeroes in the functions without this parameter.
  </para>
 </sect2>

 <sect2>
  <title>Random-Data Functions</title>

  <indexterm>
   <primary>gen_random_bytes</primary>
  </indexterm>

<synopsis>
gen_random_bytes(count integer) returns bytea
</synopsis>
  <para>
   Returns <parameter>count</> cryptographically strong random bytes.
   At most 1024 bytes can be extracted at a time.  This is to avoid
   draining the randomness generator pool.
  </para>

  <indexterm>
   <primary>gen_random_uuid</primary>
  </indexterm>

<synopsis>
gen_random_uuid() returns uuid
</synopsis>
  <para>
   Returns a version 4 (random) UUID.
  </para>
 </sect2>

 <sect2>
  <title>Notes</title>

  <sect3>
   <title>Configuration</title>

   <para>
    <filename>pgcrypto</> configures itself according to the findings of the
    main PostgreSQL <literal>configure</literal> script.  The options that
    affect it are <literal>--with-zlib</literal> and
    <literal>--with-openssl</literal>.
   </para>

   <para>
    When compiled with zlib, PGP encryption functions are able to
    compress data before encrypting.
   </para>

   <para>
    When compiled with OpenSSL, there will be more algorithms available.
    Also public-key encryption functions will be faster as OpenSSL
    has more optimized BIGNUM functions.
   </para>

   <table id="pgcrypto-with-without-openssl">
    <title>Summary of Functionality with and without OpenSSL</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Functionality</entry>
       <entry>Built-in</entry>
       <entry>With OpenSSL</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>MD5</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>SHA1</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>SHA224/256/384/512</entry>
       <entry>yes</entry>
       <entry>yes (Note 1)</entry>
      </row>
      <row>
       <entry>Other digest algorithms</entry>
       <entry>no</entry>
       <entry>yes (Note 2)</entry>
      </row>
      <row>
       <entry>Blowfish</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>AES</entry>
       <entry>yes</entry>
       <entry>yes (Note 3)</entry>
      </row>
      <row>
       <entry>DES/3DES/CAST5</entry>
       <entry>no</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>Raw encryption</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>PGP Symmetric encryption</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
      <row>
       <entry>PGP Public-Key encryption</entry>
       <entry>yes</entry>
       <entry>yes</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Notes:
   </para>

   <orderedlist>
    <listitem>
     <para>
      SHA2 algorithms were added to OpenSSL in version 0.9.8.  For
      older versions, <filename>pgcrypto</> will use built-in code.
     </para>
    </listitem>
    <listitem>
     <para>
      Any digest algorithm OpenSSL supports is automatically picked up.
      This is not possible with ciphers, which need to be supported
      explicitly.
     </para>
    </listitem>
    <listitem>
     <para>
      AES is included in OpenSSL since version 0.9.7.  For
      older versions, <filename>pgcrypto</> will use built-in code.
     </para>
    </listitem>
   </orderedlist>
  </sect3>

  <sect3>
   <title>NULL Handling</title>

   <para>
    As is standard in SQL, all functions return NULL, if any of the arguments
    are NULL.  This may create security risks on careless usage.
   </para>
  </sect3>

  <sect3>
   <title>Security Limitations</title>

   <para>
    All <filename>pgcrypto</> functions run inside the database server.
    That means that all
    the data and passwords move between <filename>pgcrypto</> and client
    applications in clear text.  Thus you must:
   </para>

   <orderedlist>
    <listitem>
     <para>Connect locally or use SSL connections.</para>
    </listitem>
    <listitem>
     <para>Trust both system and database administrator.</para>
    </listitem>
   </orderedlist>

   <para>
    If you cannot, then better do crypto inside client application.
   </para>

   <para>
    The implementation does not resist
    <ulink url="http://en.wikipedia.org/wiki/Side-channel_attack">side-channel
    attacks</ulink>.  For example, the time required for
    a <filename>pgcrypto</> decryption function to complete varies among
    ciphertexts of a given size.
   </para>
  </sect3>

  <sect3>
   <title>유익한 읽을 거리</title>

   <itemizedlist>
    <listitem>
     <para><ulink url="http://www.gnupg.org/gph/en/manual.html"></ulink></para>
     <para>GNU 개인정보 소책자.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.openwall.com/crypt/"></ulink></para>
     <para>crypt-blowfish 알고리즘 소개.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.stack.nl/~galactus/remailers/passphrase-faq.html"></ulink>
     </para>
     <para>좋은 비밀번호 만드는 방법.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://world.std.com/~reinhold/diceware.html"></ulink></para>
     <para>비밀번호를 선택하는 재미난 방법.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.interhack.net/people/cmcurtin/snake-oil-faq.html"></ulink>
     </para>
     <para>암호 기술의 장단점.</para>
    </listitem>
   </itemizedlist>
  </sect3>

  <sect3>
   <title>기술 참고</title>

   <itemizedlist>
    <listitem>
     <para><ulink url="http://www.ietf.org/rfc/rfc4880.txt"></ulink></para>
     <para>OpenPGP 메시지 양식.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.ietf.org/rfc/rfc1321.txt"></ulink></para>
     <para>MD5 메시지-다이제스트 알고리즘.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://www.ietf.org/rfc/rfc2104.txt"></ulink></para>
     <para>HMAC: 메시지 인증용 키기반-해시.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://www.usenix.org/events/usenix99/provos.html"></ulink>
     </para>
     <para>crypt-des, crypt-md5, bcrypt 알고리즘 비교.</para>
    </listitem>
    <listitem>
     <para>
      <ulink url="http://en.wikipedia.org/wiki/Fortuna_(PRNG)"></ulink>
     </para>
     <para>Fortuna 난수 생성기.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://jlcooke.ca/random/"></ulink></para>
     <para>리눅스용 Jean-Luc Cooke Fortuna-기반 <filename>/dev/random</> 드라이버.</para>
    </listitem>
    <listitem>
     <para><ulink url="http://research.cyber.ee/~lipmaa/crypto/"></ulink></para>
     <para>암호학에 대한 이야기 모음.</para>
    </listitem>
   </itemizedlist>
  </sect3>
 </sect2>

 <sect2>
  <title>만든이</title>

  <para>
   Marko Kreen <email>markokr@gmail.com</email>
  </para>

  <para>
   <filename>pgcrypto</filename> 모듈은 다음 소스 코드를 이용했다:
  </para>

  <informaltable>
   <tgroup cols="3">
    <thead>
     <row>
      <entry>알고리즘</entry>
      <entry>만든이</entry>
      <entry>원래 소스 코드</entry>
     </row>
    </thead>
    <tbody>
     <row>
      <entry>DES crypt</entry>
      <entry>David Burren과 그 외</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
     <row>
      <entry>MD5 crypt</entry>
      <entry>Poul-Henning Kamp</entry>
      <entry>FreeBSD libcrypt</entry>
     </row>
     <row>
      <entry>Blowfish crypt</entry>
      <entry>Solar Designer</entry>
      <entry>www.openwall.com</entry>
     </row>
     <row>
      <entry>Blowfish cipher</entry>
      <entry>Simon Tatham</entry>
      <entry>PuTTY</entry>
     </row>
     <row>
      <entry>Rijndael cipher</entry>
      <entry>Brian Gladman</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
     <row>
      <entry>MD5 hash 및 SHA1</entry>
      <entry>WIDE Project</entry>
      <entry>KAME kame/sys/crypto</entry>
     </row>
     <row>
      <entry>SHA256/384/512 </entry>
      <entry>Aaron D. Gifford</entry>
      <entry>OpenBSD sys/crypto</entry>
     </row>
     <row>
      <entry>BIGNUM math</entry>
      <entry>Michael J. Fromberger</entry>
      <entry>dartmouth.edu/~sting/sw/imath</entry>
     </row>
    </tbody>
   </tgroup>
  </informaltable>
 </sect2>

</sect1>
